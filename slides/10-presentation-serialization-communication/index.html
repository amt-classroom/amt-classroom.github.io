<!doctype html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Presentation</title>

    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" crossorigin="anonymous">
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/theme/white.css" crossorigin="anonymous" id="theme">
    <script src="/node_modules/reveal.js/dist/reveal.js"></script>
    <script src="/node_modules/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="/node_modules/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="/node_modules/reveal.js/plugin/notes/notes.js"></script>
    <script src="/node_modules/reveal.js/plugin/search/search.js"></script>
    <script src="/slides/script.js" type="module"></script>
    <link rel="stylesheet" href="/css/solarized-light.css" />
    <link rel="stylesheet" href="/slides/style.css">


    <script src="/fontawesome-6.4.2/js/all.min.js"></script>
</head>

<body>
    <div class="reveal">
        <div class="slides">

            <!-- Title and outline -->
            <section data-background="#333333">
                <h2>AMT</h2>
                <h1>Presentation, Serialization and Communication</h1>
                <p>Bertil Chapuis</p>
            </section>

            <section data-markdown>
                <textarea data-template>
                    ## <i class="fas fa-tasks"></i> Overview of Today's Class
                    - Presentation layer
                    - Java serialization
                    - XML serialization
                    - JSON serialization
                    - Protobuf and gRPC
                </textarea>
            </section>

            <section data-markdown>
                <textarea data-template>
                    ## <i class="fas fa-hand-paper"></i> Companion Repositories

                    Checkout the companion repositories for this course:
                    - [Presentation layer](https://github.com/amt-classroom/example-presentation)
                    - [Serialization and communication](https://github.com/amt-classroom/example-serialization-and-communication)

                </textarea>
            </section>

            <!-- Presentation Layer -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-paint-roller"></i> Presentation Layer</h2>
                </section>
                <section>
                    <img src="/images/presentation-layer.png" style="width: 50%;" alt="Presentation Layer">
                </section>
                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-paint-roller"></i> Data Transfer Objects (DTO)

                        Data Transfer Objects (DTOs) are objects that carry data between processes:
                        - They are often used in the presentation layer to transfer data between the client and the server
                        - They are closely related to serialization and deserialization
                        - They should not contain any business logic
                        - They should not mirror the domain model and leak domain logic

                        Notes:

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-paint-roller"></i> Mappers, Assemblers, Adapters, etc.

                        Data transfer objects are often mapped to domain objects using mappers, assemblers, adapters, etc.

                        Start with simple mapping logic located in the presentation layer and refactor it to a dedicated layer if needed.

                        Notes:
                        Popular mapping tools in Java:
                        * https://modelmapper.org/
                        * https://mapstruct.org/

                    </textarea>
                </section>
                <section>
                    <img src="/images/mapper.png" style="width: 50%;" alt="Mapper">
                </section>
                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-hand-paper"></i> Using Entities as DTOs

                        In some cases (examples, proof of concepts, etc.), entities are used as DTOs.

                        In your opinion, is this a good idea? What are the advantages and disadvantages of such an approach?

                        Notes:

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-paint-roller"></i> JAX-RS and RESTEasy

                        [Jakarta RESTful Web Services (JAX-RS)](https://jakarta.ee/specifications/restful-ws/) is a specification for building RESTful web services.

                        [RESTEasy](https://resteasy.dev/) is a popular JAX-RS implementation maintained by Red Hat.

                        Notes:

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-paint-roller"></i> Testing the Presentation Layer

                        There is a tendency to not test the presentation layer or to test it with complex system tests (Selenium, Puppeteer, etc.).

                        Recall the testing pyramid and the importance of unit and integration tests.

                        [REST-assured](https://rest-assured.io/) is a library that can be used to test REST APIs. Use such tools extensively to test your presentation layer.

                        Notes:

                    </textarea>
                </section>

            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-file-export"></i> Java Serialization</h2>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-file-export"></i> What is Serialization?

                        Serialization is the process of converting an object's state into a byte stream:
                        - The byte stream can be persisted to a file, database, or sent over a network
                        - Byte streams are often lighter than text (less disk space and bandwidth)

                        Why do we need serialization?
                        - To save and restore the state of an object
                        - To send an object over a network

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-file-export"></i> Key Concepts in Java Serialization

                        - **Serializable interface**: A marker interface (`java.io.Serializable`) with no methods that classes must implement to be serializable
                        - **ObjectOutputStream and ObjectInputStream**: Used for writing and reading objects to/from a byte stream
                        - **SerialVersionUID**: A unique identifier to verify the sender and receiver of a serialized object (recommended to declare explicitly for consistent deserialization)
                        - **Transient keyword**: Fields marked as transient are not serialized (useful for fields that should not be persisted)
                        - **Static fields**: Static fields are not serialized as they are not part of the object's state

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-file-export"></i> Serializable Example

                        ```java
                        class Person implements Serializable {
                            private static final long serialVersionUID = 1L;
                            private String name;
                            private int age;
                            private transient String ignoredField = "This field will not be serialized";

                            public Person(String name, int age) {
                                this.name = name;
                                this.age = age;
                            }

                            @Override
                            public String toString() {
                                return "Person{" +  "name='" + name + '\'' + ", age=" + age + '}';
                            }
                        }

                        public class Main {
                            public static void main(String[] args) throws Exception {
                                var p1 = new Person("John", 42);
                                var p2 = new Person("Jane", 36);

                                // Write the objects to a file
                                try (var oos = new ObjectOutputStream(new FileOutputStream("persons.ser"))) {
                                    oos.writeObject(p1);
                                    oos.writeObject(p2);
                                }

                                // Read the objects from the file
                                try (var ois = new ObjectInputStream(new FileInputStream("persons.ser"))) {
                                    var p3 = (Person) ois.readObject();
                                    System.out.println(p3);
                                    var p4 = (Person) ois.readObject();
                                    System.out.println(p4);
                                }
                            }
                        }
                        ```
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-file-export"></i> Taking Control of Serialization

                        **Custom serialization** allows you to override the default serialization process:
                        - Useful for handling special cases
                        - Improves performance

                        **Externalizable interface** provides complete control over the serialization process:
                        - Requires implementing `writeExternal` and `readExternal` methods

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-file-export"></i> Externalizable Example

                        ```java
                        class Person implements Externalizable {
                            private static final long serialVersionUID = 1L;
                            private String name;
                            private int age;

                            public Person() {
                                // Required for Externalizable
                            }

                            public Person(String name, int age) {
                                this.name = name;
                                this.age = age;
                            }

                            @Override
                            public void writeExternal(ObjectOutput out) throws IOException {
                                out.writeUTF(name);
                                out.writeInt(age);
                            }

                            @Override
                            public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
                                name = in.readUTF();
                                age = in.readInt();
                            }

                            @Override
                            public String toString() {
                                return "Person{" + "name='" + name + '\'' + ", age=" + age + '}';
                            }
                        }
                        ```
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-file-export"></i> Remote Method Invocation (RMI)

                        RMI (Remote Method Invocation) was a Java API that performs remote communication between Java objects using serialization.

                        RMI allowed Java objects to communicate over the network, but it had limitations:
                        - Java-to-Java communication only
                        - Java serialization only
                        - No support for other languages or platforms
                        - No support for other data formats

                        It has been **deprecated** in favor of more modern technologies.

                    </textarea>
                </section>
            </section>


            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-code"></i> XML Serialization</h2>
                </section>
                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-code"></i> What is XML?

                        XML (eXtensible Markup Language) is a markup language that defines rules for encoding documents in a human-readable and machine-readable format:
                        - It is a standard for data exchange, configuration files, web services, etc.
                        - Many technologies are based on XML (e.g., DOCX, SVG, RSS, etc.)
                        - It is still widely used in the industry

                        **DTD and XSD** are used to define the structure of an XML document:
                        - DTD (Document Type Definition) is the older standard
                        - XSD (XML Schema Definition) is the newer standard

                        **XSL-T** (eXtensible Stylesheet Language Transformations) is a language for transforming XML documents (e.g., generate HTML, reorganize data, produce reports)

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-code"></i> XML Parsers

                        XML parsers are characterized by different types of architectures:

                        - **DOM (Document Object Model)**: Loads the entire XML document into memory, allows random access, suitable for small documents
                        - **SAX (Simple API for XML)**: Reads the XML document sequentially (streaming), event-driven (you provide callbacks), suitable for large documents
                        - **StAX (Streaming API for XML)**: Reads the XML document sequentially (streaming), pull-based (you pull and process events), suitable for large documents

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-code"></i> Jakarta XML Binding (JAXB)

                        JAXB is a Java API for XML Binding:
                        - It provides a convenient way to bind an XML schema to a representation in Java code
                        - It allows Java developers to access and process XML data without having to know XML or XML processing

                        How does JAXB work?
                        - It provides two main features: marshalling Java objects into XML and unmarshalling XML back into Java objects
                        - It uses annotations to map Java objects to XML elements
                        - It generates Java classes from an XML schema

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-code"></i> Generating Classes from an XML Schema

                        XJC (XML to Java Compiler) is a tool that generates Java classes annotated with JAXB annotations from an XML schema (XSD).

                        Plugins are available to generate JAXB classes from an XSD schema with XJC in Maven or Gradle projects.

                        These tools probably make Java the best language to deal with complex XML schemas and documents.

                        Check out [eCH](https://www.ech.ch/fr) for examples of complex XML schemas and documents used in Switzerland.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-code"></i> JAXB and JAX-RS

                        JAXB (Java Architecture for XML Binding) is often used in combination with JAX-RS (Java API for RESTful Web Services) to serialize and deserialize Java objects to and from XML.

                        ```java
                        @Path("/persons")
                        public class PersonResource {
                            @GET
                            @Produces(MediaType.APPLICATION_XML)
                            public Person getPerson() {
                                return new Person("John", 42);
                            }
                        }
                        ```

                        JAX-RS delegates the serialization and deserialization of Java objects to an XML provider such as JAXB or Jackson. JAXB annotations are used behind the scenes.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-code"></i> Limitations of XML

                        - Very verbose and inefficient
                        - No support for binary data
                        - Rather difficult to stream
                        - Rather difficult to optimize for performance
                        - Difficult to deal with outside of the Java ecosystem

                    </textarea>
                </section>
            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-file"></i> JSON Serialization</h2>
                </section>
                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-file"></i> What is JSON?

                        JSON (JavaScript Object Notation) is a lightweight data-interchange format:
                        - It is easy for humans to read and write
                        - It is easy for machines to parse and generate
                        - It is based on key-value pairs
                        - It is everywhere
                        - You can find examples [here](https://json.org/example.html)

                        [JSON Schema](https://json-schema.org/) is a vocabulary that allows you to annotate and validate JSON documents (unfortunately, it is not as widely used as XML schema).

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-file"></i> JSON and JAX-RS

                        JSON is often used in combination with JAX-RS (Java API for RESTful Web Services) to serialize and deserialize Java objects to and from JSON.

                        ```java
                        @Path("/persons")
                        public class PersonResource {
                            @GET
                            @Produces(MediaType.APPLICATION_JSON)
                            public Person getPerson() {
                                return new Person("John", 42);
                            }
                        }
                        ```

                        JAX-RS delegates the serialization and deserialization of Java objects to a JSON provider such as Jackson, Gson, or JSON-B.

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-file"></i> Limitations of JSON

                        - No support for binary data
                        - Rather difficult to stream
                        - Rather difficult to optimize for performance
                        - No support for type and schema information

                    </textarea>
                </section>
            </section>


            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-bolt"></i> Protobuf and gRPC</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-bolt"></i> What is Protobuf?

                        XML and JSON are great for human readability, but they are not the most efficient way to serialize data.

                        [Protocol Buffers (Protobuf)](https://protobuf.dev/) is a language-agnostic binary serialization format developed by Google:
                        - It lets you define the structure of your data, then use a code generator (protoc) to create source code that can read and write this data
                        - Protobuf is faster, smaller, and simpler than XML and JSON

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-bolt"></i> What is gRPC?

                        Protobuf is often used in combination with [gRPC](https://grpc.io/), a high-performance, open-source universal RPC framework:
                        - gRPC is based on HTTP/2, uses Protobuf as its interface definition language, and provides features such as authentication and bidirectional streaming
                        - It is widely used for communication between microservices and with mobile devices, and gaining popularity for the Web as well (grpc-web)
                        - gRPC is supported in many languages, including Java, Go, Python, Node.js, C++, etc.

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-bolt"></i> Limitations of Protobuf and gRPC

                        - Requires a code generator
                        - Not human-readable
                        - Not human-editable
                        - Hard to debug
                        - Not as widely used as XML and JSON

                    </textarea>
                </section>
            </section>

            <section>
                <h2><i class="fas fa-hand-paper"></i> Questions?</h2>
            </section>
        </div>
    </div>
</body>

</html>