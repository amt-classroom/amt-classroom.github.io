<!doctype html>
<html lang="en">

<head>

    <meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Messaging</title>

    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" crossorigin="anonymous">
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/theme/white.css" crossorigin="anonymous" id="theme">
    <script src="/node_modules/reveal.js/dist/reveal.js"></script>
    <script src="/node_modules/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="/node_modules/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="/node_modules/reveal.js/plugin/notes/notes.js"></script>
    <script src="/node_modules/reveal.js/plugin/search/search.js"></script>
    <script src="/slides/script.js" type="module"></script>
    <link rel="stylesheet" href="/css/solarized-light.css" />
    <link rel="stylesheet" href="/slides/style.css">


    <script src="/fontawesome-6.4.2/js/all.min.js"></script>
</head>

<body>
    <div class="reveal">
        <div class="slides">

            <!-- Title and outline -->
            <section data-background="#333333">
                <h2>AMT</h2>
                <h1>Messaging</h1>
                <p>Bertil Chapuis, Dorian Gambin</p>      
            </section>
            <section data-markdown>
                <textarea data-template>
                    ## <i class="fas fa-tasks"></i> Overview of Today's Class
                    - What is messaging and why do we need it?
                    - Messaging in Java (JMS)
                    - Messaging concepts (Queues, Topics, Messages, Request/Response)
                    - Reliability and Delivery Guarantees

                </textarea>
            </section>

            <!-- Jakarta Messaging -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-envelope"></i> Messaging</h2>
                </section>
                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> What is messaging?

                        <img src="/images/messaging.png" alt="Messaging" style="width: 100%;">

                        Notes:

                        Messaging enables communication between software components or applications.

                        Each client connects to a message broker that provides the messaging service.

                        Once connected, the system behaves like a peer-to-peer facility: clients send messages to and receive messages from any other client.
                    

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Why do we need messaging?

                        - Interoperability between different languages and platforms
                        - Decoupling of components and applications
                        - Asynchronous communication and processing
                        - High scalability and availability
                        - Load balancing and failover
                        - Etc.

                        Notes:
                    
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Jakarta Messaging

                        [Jakarta Messaging (JMS)](https://jakarta.ee/specifications/messaging/) provides a Java API for applications to create, send, receive, and read messages.

                        JMS standardization began early:
                        - JMS 1.0 in 1998
                        - JMS 1.1 in 2002
                        - JMS 2.0 in 2013
                        - JMS 2.1 in 2017
                        - JMS 3.0 in 2020
                        - JMS 3.1 in 2022

                        This long history demonstrates messaging's importance in complex systems and applications.

                        Notes:
                    
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> JMS API

                        <img src="/images/jms-simplified-api.png" alt="JMS API" style="width: 100%;">

                        Notes:

                        The **JMS API** hides the messaging system's complexity.

                        Many message brokers (runtimes) implement the JMS API (specification).

                        The **Connection Factory** is used to create a connection (old API) or a context (new API) to the message broker.

                        The **Context** is a factory for creating destinations, producers, consumers, messages, etc.

                        **Destinations** are queues or topics.

                        **Producers** send messages to a destination.

                        **Consumers** receive messages from a destination.

                        **Messages** are the data exchanged between producers and consumers.

                        source: https://jakarta.ee/specifications/messaging/3.1/jakarta-messaging-spec-3.1
                    
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-hand-paper"></i> JMS examples

                        Checkout the following repository:
                        https://github.com/amt-classroom/example-messaging

                        It demonstrates how to use the JMS API with different models (queue, topic, request/response).

                    </textarea>
                </section>


                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Connection Factory

                        The **connection factory** creates a connection to the message broker.

                        ```java
                        var connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616");
                        ```

                        In practice, a dependency injection framework injects the connection factory rather than creating it directly.

                        ```java
                        @Inject
                        ConnectionFactory connectionFactory;
                        ```
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        <img src="/images/queue-model.png" alt="Queue Model" style="width: 100%;">

                        Notes:

                        The **queue model** is the simplest messaging model, based on point-to-point (PTP) communication.

                        A **queue** is a **destination** where producers send messages and consumers receive them.

                        Each message sent to a queue reaches only one consumer.

                        This model uses fire-and-forget: the producer sends a message and forgets it. The consumer receives and processes the message. Producer and consumer remain decoupled.

                        **Queues** enable asynchronous processing, load balancing, and failover.

                        Example: a queue sends emails. The producer queues an email; a consumer sends it to the recipient.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> Queue Producer

                        Create a context from the connection factory, then create a queue, producer, and message. Send the message to the queue.


                        ```java
                        var context = connectionFactory.createContext()) {

                        // Create the queue and the producer
                        var queue = context.createQueue("queue");
                        var producer = context.createProducer();
            
                        // Create the message
                        var message = context.createTextMessage();
                        message.setText(text);
            
                        // Send the message
                        producer.send(queue, message);
                        ```
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> Queue Consumer

                        Create a context from the connection factory, then create a queue and consumer. Handle the message asynchronously.

                        ```java
                        var context = connectionFactory.createContext();
                        var queue = context.createQueue("queue");
                        var consumer = context.createConsumer(queue);
                
                        // Handle the message asynchronously
                        consumer.setMessageListener(message -> {
                            // Handle the message
                        });
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> Topic

                        <img src="/images/topic-model.png" alt="Queue Model" style="width: 100%;">

                        Notes:

                        The **Topic model** uses publish/subscribe communication.

                        A **topic** is a **destination** where producers send messages and consumers receive them.

                        Each message sent to a topic reaches one or more consumers.

                        This model uses fire-and-forget: the producer sends a message and forgets it. Consumers receive and process the message. Producer and consumers remain decoupled.

                        **Topics** enable broadcasting and event notification.

                        Example: a topic represents a stock price. The producer sends the price to the topic; all consumers receive it.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> Topic Producer

                        Create a context from the connection factory, then create a topic, producer, and message. Send the message to the topic.

                        ```java
                        var context = connectionFactory.createContext()) {

                        // Create the topic and the producer
                        var topic = context.createTopic("topic");
                        var producer = context.createProducer();
            
                        // Create the message
                        var message = context.createTextMessage();
                        message.setText(text);
            
                        // Send the message
                        producer.send(topic, message);
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> Topic Consumer

                        Create a context from the connection factory, then create a topic and consumer. Handle the message asynchronously.

                        ```java
                        // Create a JMS context
                        var context = connectionFactory.createContext();
                        var topic = context.createTopic("topic");
                        var consumer = context.createConsumer(topic);

                        // Handle the message asynchronously
                        consumer.setMessageListener(message -> {
                            // Handle the message
                        });
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Durable subscriptions

                        So far, consumers must connect to the topic to receive messages.
                        However, sometimes you want to receive messages even when the consumer disconnects.

                        Durable subscriptions solve this problem.
                        A durable subscription survives consumer disconnection.

                        To create a durable subscription, provide a client ID and subscription name.

                        ```java
                        var context = connectionFactory.createContext();
                        var topic = context.createTopic("topic");
                        var consumer = context.createDurableConsumer(topic, "subscription", "clientID");
                        ```

                        Notes:
                        
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> Request/Response

                        <img src="/images/request-response-model.png" alt="Queue Model" style="width: 100%;">

                        Notes:

                        The **Request/Response model** uses point-to-point (PTP) communication.

                        However, the producer must wait for the consumer's response, making fire-and-forget unsuitable.

                        The solution:
                        - The **producer** sends a message to a queue, creates a temporary queue, includes it in the message, and waits for the response on the temporary queue.
                        - The **consumer** receives the message, processes it, and sends the response to the temporary queue.
                        - The **producer** receives and processes the response.

                        **Request/Response** suits long asynchronous tasks (batch processing, report generation) where the producer needs to know when processing completes and results arrive.

                        Example: travel booking requires checking flight availability, seat availability, hotel availability, etc. before confirming the booking.
                    
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> Send a request and wait for the response

                        Create a context from the connection factory, then create a queue and producer. Send the request and block until the response arrives.

                        ```java
                        // Create the queue and the producer
                        var requestQueue = context.createQueue("request");
                        var requestProducer = context.createProducer();
            
                        // Create the request
                        var requestMessage = context.createTextMessage();
                        requestMessage.setText(name);
            
                        // Create the response queue and set it as the reply-to destination
                        var responseQueue = context.createTemporaryQueue();
                        requestMessage.setJMSReplyTo(responseQueue);
            
                        // Send the request
                        requestProducer.send(requestQueue, requestMessage);
            
                        // Block and wait for the response
                        var responseConsumer = context.createConsumer(responseQueue);
                        var responseMessage = responseConsumer.receive(10000L);
                        if (responseMessage instanceof TextMessage textMessage) {
                            response = textMessage.getText();
                        }
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> Handle a request and send the response

                        Create a context from the connection factory, then create a queue and consumer. Handle requests asynchronously and send responses.

                        ```java
                        var context = connectionFactory.createContext();
                        var requestQueue = context.createQueue("request");
                        var messageConsumer = context.createConsumer(requestQueue);

                        // Handle the request asynchronously
                        messageConsumer.setMessageListener(message -> {
                            try {
                                if (message instanceof TextMessage textMessage) {
                                    // Create the response
                                    var responseText = "Hello " + textMessage.getText() + "!";
                                    var responseMessage = context.createTextMessage(responseText);

                                    // Send the response to the destination specified in the request
                                    var responseDestination = message.getJMSReplyTo();
                                    var responseProducer = context.createProducer();
                                    responseProducer.send(responseDestination, responseMessage);
                                }
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        });
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Message Types

                        JMS defines different [types](https://jakarta.ee/specifications/messaging/3.1/jakarta-messaging-spec-3.1#jakarta-messaging-message-body) of messages:
                        - **TextMessage** contains a string
                        - **BytesMessage** contains a byte array
                        - **ObjectMessage** contains a serializable Java object
                        - **MapMessage** contains a set of name-value pairs
                        - **StreamMessage** contains a stream of Java primitive values
                
                    </textarea>
                </section>


                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Message Properties and Selectors

                        **Message Properties** allow producers to attach metadata to messages using key-value pairs. 

                        ```java
                        var producer = context.createProducer();
                        var message = context.createTextMessage("Hello, World!");
                        message.setStringProperty("type", "order");
                        message.setIntProperty("amount", 100);
                        producer.send(queue, message);
                        ```

                        On the consumer side, this metadata can be used in **Message Selectors** to filter messages based on their properties.

                        ```java
                        var consumer = context.createConsumer(queue, "type = 'order' AND amount > 100");
                        ```

                        This SQL-like expression syntax allows for rich filtering capabilities.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Message Acknowledgement

                        **Message acknowledgements (ACK)** ensure that messages are processed and not lost. JMS provides different **acknowledgement modes**:

                        - **AUTO_ACKNOWLEDGE**: The session automatically acknowledges messages when the consumer receives them. This is the simplest mode but may not suit all scenarios.
                        - **CLIENT_ACKNOWLEDGE**: The client explicitly acknowledges messages by calling the `acknowledge` method. This provides more control but requires additional code.
                        - **SESSION_TRANSACTED**: The session acknowledges messages as part of a transaction. This ensures atomic processing: either all messages are acknowledged or none are.
                        - **DUPS_OK_ACKNOWLEDGE**: The session lazily acknowledges message delivery. This reduces overhead but allows duplicate messages if the consumer crashes.

                        Choose the acknowledgement mode based on your application's reliability, performance, and complexity requirements.
                        
                
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> Client Acknowledge

                        Use `CLIENT_ACKNOWLEDGE` mode to explicitly acknowledge messages.

                        ```java
                        // Create a JMS context
                        var context = connectionFactory.createContext(Session.CLIENT_ACKNOWLEDGE);
                        var queue = context.createQueue("queue");
                        var consumer = context.createConsumer(queue);

                        // Handle the message asynchronously
                        consumer.setMessageListener(message -> {
                            try {
                                // Process the message
                            } catch (Exception e) {
                                // Handle the error
                            } finally {
                                // Acknowledge the message
                                message.acknowledge();
                            }
                        });
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fa-solid fa-envelope"></i> Session Transacted

                        Use `SESSION_TRANSACTED` mode to process message groups atomically.

                        ```java
                        // Create a JMS context with transacted session
                        var context = connectionFactory.createContext(Session.SESSION_TRANSACTED);
                        var queue = context.createQueue("queue");
                        var producer = context.createProducer();
                        var consumer = context.createConsumer(queue);

                        try {
                            // Send a message
                            var message = context.createTextMessage("Hello, World!");
                            producer.send(queue, message);

                            // Receive and process the message
                            var receivedMessage = consumer.receive();

                            // Commit the transaction
                            context.commit();
                        } catch (Exception e) {
                            // Rollback the transaction in case of an error
                            context.rollback();
                        }
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Ordering guarantees

                        Brokers provide different ordering guarantees:
                        - **Out-of-order** - Messages are not ordered.
                        - **FIFO** - First message in is the first message out.
                        - **LIFO** - Last message in is the first message out.
                        - **Priority** - Messages are ordered by priority.

                        Notes:
                        Make no assumptions about the broker's guarantees.
                        Always check the broker's documentation for specific guarantees.

                
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Delivery guarantees

                        Brokers provide different delivery guarantees:
                        - **At most once** - The message may be delivered once or not at all.
                        - **At least once** - The message is always delivered but may arrive multiple times.
                        - **Exactly once** - The message is delivered once and only once.


                        Notes:
                        Make no assumptions about the broker's guarantees.
                        Always check the broker's documentation for specific guarantees and from which perspective (producer or consumer).

                        References:
                        * https://kafka.apache.org/documentation/#semantics
                        * https://www.rabbitmq.com/docs/reliability#confirms 
                        * https://activemq.apache.org/components/artemis/documentation/2.37.0/send-guarantees.html#guarantees-of-sends-and-commits 
                    
                
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Other guarantees

                        - **Persistent** - Messages persist on disk and survive broker crashes.
                        - **Transactional** - Messages deliver only when transactions commit.
                        - **Failover** - Messages replicate across multiple machines.
                        - **Scalability** - Messages distribute across multiple machines.

                        Notes:
                        Make no assumptions about the broker's guarantees.
                        Always check the broker's documentation for specific guarantees.

                
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        <img src="/images/delivery-guarantees-producer.png" style="width: 100%;">

                        Notes:

                        The message broker can use persistent storage to store messages on disk and provide at-least-once delivery.

                        Here, the producer sends a message to the broker, which stores it on disk. The message survives broker crashes.


                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        <img src="/images/delivery-guarantees-consumer.png" style="width: 100%;">

                        Notes:

                        Similarly, the consumer handles the message and sends an acknowledgement to the broker, which deletes the message from disk. The message survives broker crashes.
                
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-envelope"></i> Disk persistence
                        In rare cases, operating system or database bugs can cause data loss on the persistence path.
                        Some distributed systems by design acknowledge messages before fully guaranteeing disk persistence.

                        Read and discuss in class:
                        * https://lwn.net/Articles/752063/
                        * https://jack-vanlightly.com/blog/2023/4/24/why-apache-kafka-doesnt-need-fsync-to-be-safe

                        Hard persistence requirements usually increase latency to achieve strong guarantees.
                        Example: https://www.rabbitmq.com/docs/confirms#publisher-confirms-latency
                        > basic.ack for a persistent message routed to a durable queue will be sent after persisting the message to disk. The RabbitMQ message store persists messages to disk in batches after an interval (a few hundred milliseconds) to minimise the number of fsync(2) calls, or when a queue is idle.
                        > This means that under a constant load, latency for basic.ack can reach a few hundred milliseconds.

                        Notes:
                        PostgreSQL used fsync incorrectly for 20 years: https://www.youtube.com/watch?v=1VWIGBQLtxo

                       
                
                    </textarea>
                </section>
            </section>

            <section>
                <h2><i class="fas fa-hand-paper"></i> Questions?</h2>
            </section>
        </div>
    </div>
</body>
</html>