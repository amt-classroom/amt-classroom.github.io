<!doctype html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Advanced Java features</title>

    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" crossorigin="anonymous">
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/theme/white.css" crossorigin="anonymous" id="theme">
    <script src="/node_modules/reveal.js/dist/reveal.js"></script>
    <script src="/node_modules/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="/node_modules/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="/node_modules/reveal.js/plugin/notes/notes.js"></script>
    <script src="/node_modules/reveal.js/plugin/search/search.js"></script>
    <script src="/slides/script.js" type="module"></script>
    <link rel="stylesheet" href="/css/solarized-light.css" />
    <link rel="stylesheet" href="/slides/style.css">

    <script src="/fontawesome-6.4.2/js/all.min.js"></script>
</head>

<body>

    <div class="reveal">
        <div class="slides">
            <!-- Title and outline -->
            <section data-background="#333333">
                <h2>AMT</h2>
                <h1>Advanced Java features</h1>
                <p>Bertil Chapuis, Dorian Gambin</p>
            </section>
            <section data-markdown>
                <textarea data-template>
                    ## <i class="fas fa-tasks"></i> Overview of Today’s Class

                    Modern Java runtimes for multi-tier applications rely on several advanced features to provide flexibility, extensibility, and better developer experience:
                    - **Class Loaders**: control how classes are discovered and loaded
                    - **Reflection**: inspect and manipulate classes, methods, and fields at runtime
                    - **Proxies**: intercept method calls to add behavior dynamically
                    - **Runtime Annotations**: enable metadata-driven frameworks and tooling
                    - **Compile-time Annotations**: generate code and optimize application startup

                </textarea>
            </section>

            <section data-markdown>
                <textarea data-template>
                    ## <i class="fas fa-tasks"></i> Motivations

                    Framework developers aim to provide the best tools to make application development easier and more productive.

                    They often rely on advanced Java features to implement them and improve the developer experience.

                    Today, we will get a glimpse of some of these features.

                </textarea>
            </section>

            <!-- Class loaders -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-sitemap"></i> Class loaders</h2>
                </section>
                <section data-markdown style="font-size: 0.6em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Class loaders

                        Class loaders are responsible for **loading classes into the JVM at runtime**.

                        Main types of class loaders:
                        - **Bootstrap class loader:** Loads core Java classes from `$JAVA_HOME/lib/` (e.g., `java.lang.*`).
                        - **Platform class loader:** Loads platform-specific libraries; Known as the Extension class loader before JDK 9 ([JEP 261](https://openjdk.org/jeps/261#Class-loaders)).
                        - **System class loader:** Loads application classes from the classpath (e.g., `.` or JAR files).

                        Delegation Model:
                        - Each class loader delegates to its parent first.  
                        - If no parent can load the class, the loader tries itself.  
                        - Failure through the chain results in a **`ClassNotFoundException`**.  

                        📖 Reference: [Java 21 built-in class loaders](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ClassLoader.html#builtinLoaders)  
                    
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Examples

                        Finding the class loader of a class:

                        ```java
                        System.out.println(MyClass.class.getClassLoader()); // AppClassLoader (application class loader)
                        System.out.println(DriverManager.class.getClassLoader()); // PlatformClassLoader (extension class loader)
                        System.out.println(String.class.getClassLoader()); // null (bootstrap class loader)
                        ```

                        Examining the delegation chain in a stack trace:

                        ```java
                        Class<?> clazz = Class.forName("ch.heigvd.amt.MyClass");
                        ```

                        ```
                        Exception in thread "main" java.lang.ClassNotFoundException: com.example.MyClass
                        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)
                        at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)
                        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
                        at java.base/java.lang.Class.forName0(Native Method)
                        at java.base/java.lang.Class.forName(Class.java:375)
                        at Main.main(Main.java:6)
                        ```

                    </textarea>
                </section>


                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Custom Class Loaders

                        Custom class loaders are useful when the default loading mechanism isn’t enough.  
                        
                        They enable scenarios such as:  
                        - Loading classes from non-standard sources (e.g., network, encrypted files)  
                        - Reloading classes at runtime (e.g., hot-swapping code)  
                        - Transforming classes dynamically (e.g., bytecode manipulation)  
                        - Supporting modularity or versioning  
                        
                        Real-world examples:
                        - **Spring Boot**: reloads classes when the application is [restarted](https://github.com/spring-projects/spring-boot/blob/2dbf7d9c255a7f9f7a736a92e5d72c6d229489b7/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/restart/classloader/RestartClassLoader.java#L38).  
                        - **Quarkus**: supports [hot reload](https://quarkus.io/guides/class-loading-reference) in development mode.  
                        - **OSGi frameworks**: manage modularity and versioning of Java applications.  

                    </textarea>
                </section>


                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Creating a custom class loader

                        To create a custom class loader, you can extend the `ClassLoader` class and override the `findClass` method.

                        ```java
                        public class CustomClassLoader extends ClassLoader {

                            public CustomClassLoader(ClassLoader parent) {
                                super(parent);
                            }

                            @Override
                            protected Class<?> findClass(String name) throws ClassNotFoundException {
                                // Load the class from a custom source
                                System.out.println("Trying to load class with custom class loader: " + name);
                        
                                // If the class is not found, delegate to the parent class loader
                                return super.findClass(name);
                            }

                            public static void main(String[] args) throws Exception {
                                // Create a new CustomClassLoader with the system class loader as its parent
                                CustomClassLoader customClassLoader = new CustomClassLoader(ClassLoader.getSystemClassLoader());
                        
                                // Load the class using the custom class loader
                                Class<?> clazz = customClassLoader.loadClass("java.sql.DriverManager");
                            }

                        }
                        ```
                        
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">

                        ## Changing the default class loader

                        Changing the default class loader at startup:

                        ```
                        java -Djava.system.class.loader=com.example.MyClassLoader com.example.Main
                        ```

                        Changing the default class loader programmatically:

                        ```
                        Thread.currentThread().setContextClassLoader(classLoader);
                        ```

                        A thread factory can be used to create new threads with a custom class loader.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## For More Fun

                        - Explore the [`URLClassLoader`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/URLClassLoader.html) to load classes directly from **URLs**.  
                        - Try the [`example-classloader`](https://github.com/amt-classroom/example-classloader) project to see how you can:  
                          - Compile Java files on the fly with the **Java Compiler API**  
                          - Generate classes dynamically with the new **ClassFile API** (Java 23+) 
                    </textarea>
                </section>

            </section>

            <!-- Advanced Java Features -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-sitemap"></i> Reflection</h2>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Reflection

                        Reflection refers to the ability of a program to inspect and modify its structure and behavior at runtime.

                        In multi-tier applications, reflection is often used to:
                        - Dynamically load classes
                        - Dynamically create objects
                        - Dynamically invoke methods
                        - Dynamically access fields
                        - Code generation

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## <i class="fas fa-microscope"></i> Reflection API

                        The **Reflection API** (in `java.lang.reflect`) allows programs to inspect and manipulate classes at runtime:
                        
                        - **`Class<?>`**: represents a loaded class or interface  
                        - **`Method`**: describes and invokes a method  
                        - **`Field`**: describes and accesses a field (variables)  
                        - **`Constructor`**: describes and creates new instances  
                        
                        📖 Reference: [Java Reflection API docs](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/reflect/package-summary.html)  
                        

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">

                        ## Example of using the Reflection API

                        ```java
                        import java.lang.reflect.*;

                        // Instantiate an object
                        Class<?> clazz = Class.forName("com.example.MyClass");
                        Object object = clazz.newInstance();

                        // Invoke a method of the object
                        Method method = clazz.getMethod("myMethod");
                        method.invoke(object);

                        // Set an object's field with a given value
                        Field field = clazz.getField("myField");
                        field.set(object, "myValue");
                        ```

                        Consult the Java documentation for more information:
                        https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/reflect/package-summary.html

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Reflection and OOP

                        Reflection offers powerful flexibility, but it can also **violate core OOP principles**:
                        
                        - ⚠️ **Encapsulation risk**: private fields and methods can be accessed or modified  
                        - ⚠️ **Safety concerns**: bypasses compile-time checks, increasing runtime errors  
                        - ⚠️ **Performance cost**: reflective operations are slower than direct calls  
                        
                        Use reflection **with caution**: it’s best reserved for frameworks and tooling, not everyday code.  

                    </textarea>
                </section>
            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-sitemap"></i> Proxies</h2>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Proxies

                        A proxy is an object that acts as an interface to another object.

                        In multi-tier applications, proxies are often used to:
                        - Intercept method calls
                        - Add behavior to method calls
                        - Implement lazy loading
                        - Implement caching
                        - Implement transactions
                        - Implement security checks

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        A simple interface and its implementation.
                        ```java
                        interface MyInterface {
                            void myMethod();
                        }

                        class MyInterfaceImpl implements MyInterface {
                            @Override
                            public void myMethod() {
                                System.out.println("Hello World!");
                            }
                        }
                        ```
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ```java
                        import java.lang.reflect.*;

                        // Assuming here MyInterface and MyInterfaceImpl definitions

                        public class MyInvocationHandler implements InvocationHandler {
                            private final Object target;
        
                            public MyInvocationHandler(Object target) {
                                this.target = target;
                            }
        
                            @Override
                            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                System.out.println("Before method call");
                                Object result = method.invoke(target, args);
                                System.out.println("After method call");
                                return result;
                            }
                        }

                        public class App {
                            public static void main(String[] args) {
                                MyInterface object = new MyInterfaceImpl();
                                MyInvocationHandler handler = new MyInvocationHandler(object);
                                MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
                                    MyInterface.class.getClassLoader(),
                                    new Class[] { MyInterface.class },
                                    handler
                                );
                                proxy.myMethod();
                            }
                        }
                        ```
                    </textarea>
                </section>
            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-sitemap"></i> Runtime annotations</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Runtime annotations

                        Annotations are a form of metadata that can be added to Java classes, methods, and fields.

                        In multi-tier applications, annotations are often used to:
                        - Implement dependency injection
                        - Implement persistence
                        - Implement validation
                        - Implement security checks

                        Annotations can be read at runtime using reflection.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        Processing annotations at runtime of application.
                        ```java
                        import java.lang.annotation.*;

                        @Retention(RetentionPolicy.RUNTIME)
                        @Target(ElementType.TYPE)
                        @interface MyAnnotation {
                            String value();
                        }

                        @MyAnnotation("Hello World!")
                        class MyClass {
                        }

                        public class MyAnnotationProcessor {
                            public static void main(String[] args) {
                                Class<?> clazz = Class.forName("com.example.MyClass");
                                MyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);
                                System.out.println(annotation.value());
                            }
                        }
                        ```
                    </textarea>
                </section>
            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-sitemap"></i> Compile-time annotations</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Compile-time annotations

                        Annotations can be used at compile-time to generate code.

                        Recently compile-time annotations have been used to accelerate the startup time of large Java applications.

                        A significant amount of time was spent at startup to introspect the program, load and initialize classes.

                        Compile-time annotations must be processed by a compiler plugin called an annotation processor.

                        Both the compile-time annotations and the annotation processor must be compiled and added to the classpath of the compiler.

                        Notes:
                        Examples of compile-time annotations improving startup of Java applications:
                        * https://dagger.dev/ (dependency injection)
                        * https://projectlombok.org/ (generation of boilerplate code)
                        * https://mapstruct.org/ (generate mappers)
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        Implementation stub of compile-time annotations processor.

                        ```java
                        import javax.annotation.processing.*;
                        import javax.lang.model.SourceVersion;
                        import javax.lang.model.element.*;
                        import javax.lang.model.type.TypeMirror;

                        @SupportedAnnotationTypes("mypackage.MyAnnotation")
                        @SupportedSourceVersion(SourceVersion.RELEASE_8)
                        public class MyAnnotationProcessor extends AbstractProcessor {

                            @Override
                            public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
                                // process the annotation and generate code
                                return true;
                            }
                        }
                        ```
                    </textarea>
                </section>
            </section>

            <section>
                <h2><i class="fas fa-hand-paper"></i> Questions?</h2>
            </section>

        </div>
    </div>

</body>

</html>
