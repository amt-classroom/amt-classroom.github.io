<!doctype html>
<html lang="en">

<head>

    <meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Manipulating and querying data</title>

    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" crossorigin="anonymous">
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/theme/white.css" crossorigin="anonymous" id="theme">
    <script src="/node_modules/reveal.js/dist/reveal.js"></script>
    <script src="/node_modules/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="/node_modules/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="/node_modules/reveal.js/plugin/notes/notes.js"></script>
    <script src="/node_modules/reveal.js/plugin/search/search.js"></script>
    <script src="/slides/script.js" type="module"></script>
    <link rel="stylesheet" href="/css/solarized-light.css" />
    <link rel="stylesheet" href="/slides/style.css">

    <script src="/fontawesome-6.4.2/js/all.min.js"></script>
</head>

<body>

    <div class="reveal">
        <div class="slides">
            <!-- Title and outline -->
            <section data-background="#333333">
                <h2>AMT</h2>
                <h1>Manipulating and querying data</h1>
                <p>Bertil Chapuis, Dorian Gambin</p>
            </section>
            <section data-markdown>
                <textarea data-template>
                    ## <i class="fas fa-tasks"></i> Overview of Today's Class
                    - Manipulating data
                    - Querying databases
                    - Object relational impedance mismatch
                </textarea>
            </section>

            <!-- Manipulating data -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-database"></i> Manipulating data </h2>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Manipulating data

                        Let's consider the following model:
                        - Person(id, first_name, last_name)
                        - Order(id, person_id, date)
                        - OrderLine(id, order_id, item_id, quantity)
                        - Item(id, name, price)

                        We will use this model in today's class to illustrate different ways to access data.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Person entity

                        ```java
                        @Entity(name = "persons")
                        public class Person {
                        
                            @Id
                            @Column(name = "id", nullable = false)
                            private Long id;
                        
                            @Column(name = "first_name", nullable = false)
                            private String firstName;
                        
                            @Column(name = "last_name", nullable = false)
                            private String lastName;

                            @OneToMany
                            private List<Order> orders;

                            // ...
                        }
                        ```
                    </textarea>
                </section>
                
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Order entity

                        ```java
                        @Entity(name = "orders")
                        public class Order {

                            @Id
                            @Column(name = "id", nullable = false)
                            private Long id;

                            @OneToMany
                            private List<OrderLine> orderLines;

                            // ...
                        }
                        ```
                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fas fa-database"></i> Order line entity

                        ```java
                        @Entity(name = "order_lines")
                        public class OrderLine {

                            @Id
                            @Column(name = "id", nullable = false)
                            private Long id;

                            @ManyToOne
                            private Item item;

                            @Column(name = "quantity", nullable = false)
                            private int quantity;
                            
                            // ...
                        }
                        ```
                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>

                        ## <i class="fas fa-database"></i> Item entity

                        ```java
                        @Entity(name = "items")
                        public class Item {
                        
                            @Id
                            @Column(name = "id", nullable = false)
                            private Long id;
                        
                            @Column(name = "price", nullable = false)
                            private int price;

                            // ...
                        }
                        ```
                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Generated schema

                        <img src="./images/generated-schema.png" alt="Generated schema" style="width: 80%;">

                        Notes:

                        Hibernate will automatically generate the database schema based on the entities.

                        This is very convenient for development, but should not be used in production.

                        Does this schema look good to you?
                        
                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.4em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Why join tables are used in the generated schema?
                        In summary the relationships in JPA have an owning side that controls the relation, the annotation `@OneToMany` alone (i.e without a reverse `@ManyToOne`) creates an unidirectional relationship. Since the owning side doesn't specify more information, the default mapping applies. In order to specify a relationship with foreign key in the non-owning side, more information must be given to JPA.

                        **Jakarta Persistence
 3.1, [2.11.5.1. Unidirectional OneToMany Relationships](https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1#a764):**
                        
                        <i class="fa-solid fa-quote-left"></i> 
                        The following mapping defaults apply:
                        * Entity A is mapped to a table named A.
                        * Entity B is mapped to a table named B.
                        * There is a join table that is named A_B (owner name first). This join table has two foreign key columns. One foreign key column refers to table A [...] The other foreign key column refers to table B [...] 
                        <i class="fa-solid fa-quote-right"></i> 
                        
                        **Jakarta Persistence
 3.1, [2.10. Entity Relationships](https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1#a516):**

                        <i class="fa-solid fa-quote-left"></i>
                        The mapping of unidirectional one-to-many relationships by means of foreign key mappings. The JoinColumn annotation or corresponding XML element must be used to specify such non-default mappings.
                        <i class="fa-solid fa-quote-right"></i> 
                        
                        
                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Always tell the ORM what to do!

                        In the `Person` class: 
                        ```java
                        @OneToMany
                        @JoinColumn(name = "person_id", referencedColumnName = "id")
                        private List<Order> orders;
                        ```

                        In the `Order` class:
                        ```java
                        @OneToMany
                        @JoinColumn(name = "order_id", referencedColumnName = "id")
                        private List<OrderLine> orderLines;
                        ```

                        In the `OrderLine` class:
                        ```java
                        @ManyToOne
                        @JoinColumn(name = "item_id", referencedColumnName = "id")
                        private Item item;
                        ```

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Improved generated schema

                        <img src="./images/generated-schema-improved.png" alt="Generated schema" style="width: 40%;">
                        
                        
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.4em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Entity Instance’s Life Cycle
                        **Jakarta Persistence
                        3.1, [3.2. Entity Instance’s Life Cycle](https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1#a1929):**
                        

                        A **new** entity instance has no persistent identity, and is not yet associated with a persistence context.
                        ```java
                        var p = new Person("John", "Doe");
                        ```

                        A **managed** entity instance is an instance with a persistent identity that is currently associated with a persistence context.
                        ```java
                        var p = new Person("John", "Doe");
                        em.persist(p);
                        ```
                        ```java
                        var p = em.find(Person.class, 1L);
                        ```

                        A **detached entity** instance is an instance with a persistent identity that is not (or no longer) associated with a persistence context.
                        A detached entity results from transaction commit if a transaction-scoped persistence context is used; from transaction rollback; from detaching the entity from the persistence context; from clearing the persistence context; from closing an entity manager.
                        ```java
                        var p = em.find(Person.class, 1L);
                        em.detach(p);
                        ```

                        A **removed** entity instance is an instance with a persistent identity, associated with a persistence context, that will be removed from the database upon transaction commit.
                        ```java
                        var p = em.find(Person.class, 1L);
                        em.remove(p);
                        ```
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Create

                        In this example, the entity manager is used to persist a new person.

                        ```java
                        // Getting the entity manager
                        EntityManager em = ...;
                    
                        // Creating a person
                        em.persist(new Person("John", "Doe"));
                        em.persist(new Person("Jane", "Doe"));
                        ```

                        Here, the persist() method will create a new row in the database, and assign an id to the person.
                        Each call to persist() will execute a SQL INSERT statement.

                        ```SQL
                        INSERT INTO person (first_name, last_name) VALUES ('John', 'Doe');
                        INSERT INTO person (first_name, last_name) VALUES ('Jane', 'Doe');
                        ```

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.4em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Update and removal operation

                        In this example, the entity manager is used to find a person and update it.
                        ```java
                        // Getting the entity manager
                        EntityManager em = ...;

                        // Finding a person
                        Person person = em.find(Person.class, 1L);

                        // Updating the person through its managed entity
                        person.setFirstName("John");
                        person.setLastName("Smith");

                        // The person instance being managed since it is returned by the EntityManager, it will be synchronized to the database by the JPA implementation
                        ```

                        In this example, the entity manager is used to find a person and remove it.
                        ```java
                        // Getting the entity manager
                        EntityManager em = ...;

                        // Finding a person
                        Person person = em.find(Person.class, 1L);

                        // Removal of the entity
                        em.remove(person);

                        // The person instance being managed since it is returned by the EntityManager, it will be synchronized to the database by the JPA implementation
                        ```

                        **Jakarta Persistence
 3.1, [3.2.4. Synchronization to the Databases](https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1#a1955):** 

                        <i class="fa-solid fa-quote-left"></i>The state of persistent entities is synchronized to the database upon transaction commit. This synchronization involves writing to the database any updates to persistent entities and their relationships. [...] The persistence provider runtime is permitted to perform synchronization on the database at other times as well as when a transaction is active and the persistence context is joined to the transaction. The flush method can be used by the application to force synchronization. [...]
                        <i class="fa-solid fa-quote-right"></i>

                        <i class="fa-solid fa-circle-exclamation"></i> To better understand **when** and **what** happens during the synchronization:
                        1. activate the logging of SQL queries `quarkus.hibernate-orm.log.sql=true`
                        2. use the debugger with breakpoints and execute step-by-step.
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Batch insert and update

                        When inserting or updating a large number of rows, it is more efficient to use batch operations.

                        In a database, the default behavior is to commit each operation individually.

                        This is not efficient when inserting or updating a large number of rows.
                        
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Batch with JDBC

                        Using JDBC, you can use the addBatch() method to add a batch operation.

                        ```java
                        PreparedStatement statement = connection.prepareStatement("INSERT INTO person (first_name, last_name) VALUES (?, ?)");
                        statement.setString(1, "John");
                        statement.setString(2, "Doe");
                        statement.addBatch();
                        statement.setString(1, "Jane");
                        statement.setString(2, "Doe");
                        statement.addBatch();
                        statement.executeBatch();
                        ```
                        
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Batch with JPA

                        By default, Hibernate does not use JDBC batching capabilities. However it is possible to enable it globally or per session.

                        Hibernate ORM User Guide 6.6, [13.1. JDBC batching](https://docs.jboss.org/hibernate/orm/6.6/userguide/html_single/Hibernate_User_Guide.html#batch-jdbcbatch)

                        <i class="fa-solid fa-quote-left"></i> 
                        `hibernate.jdbc.batch_size`:
                        Controls the maximum number of statements Hibernate will batch together before asking the driver to execute the batch. Zero or a negative number disables this feature.<i class="fa-solid fa-quote-right"></i> 
                        </p>

                        Quarkus corresponding configuration: 
                        [ `quarkus.hibernate-orm.jdbc.statement-batch-size`](https://quarkus.io/guides/hibernate-orm#quarkus-hibernate-orm_quarkus-hibernate-orm-jdbc-statement-batch-size
                        )

                        Anti-pattern of filling the persistent context within a transaction leading to a memory leak that coud result in out of memory errors:
                        ```java
                        EntityManager entityManager = ...;

                        for (int i = 0; i < 100_000; i++) {
                            Person Person = new Person(String.format("Jon %d", i), String.format("Doe %d", i));
                            entityManager.persist(Person);
                        }
                        ```
                        Remember that the persistent context can be manually flushed through `EntityManager.flush()`, which triggers a database synchronization and `EntityManager.clear()` can be used to control the size of the persistent context.
                        
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Lower level mechanisms
                        
                        When inserting millions of rows, some databases offer lower level mechanisms.

                        For example, PostgreSQL offers the COPY command.

                        ```SQL
                        COPY person (first_name, last_name) FROM '/tmp/person.csv' DELIMITER ',' CSV HEADER;
                        ```

                        This command is much faster than using JDBC or JPA.

                        Further optimizations include disabling indexes, constraints, triggers, logging, etc. at the database level.

                    </textarea>
                </section>

            </section>

            <!-- Querying databases -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-database"></i> Querying databases</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Querying databases

                        Beyond the CRUD operations, we often need to perform complex queries on our data.

                        - SQL
                        - JPA JPQL
                        - JPA Named queries
                        - JPA Criteria API
                        - JPA Criteria with JPA Metamodel
                        
                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## SQL

                        SQL remains the most powerful way to query your database.

                        Lots of databases offer specific features that are not part of the standard (e.g. JSON, XML, ...).

                        ```SQL
                        var query = """
                                SELECT persons.first_name, persons.last_name, COUNT(orders.*) AS total
                                FROM persons
                                JOIN orders ON orders.person_id = persons.id
                                GROUP BY persons.first_name, persons.last_name
                                ORDER BY COUNT(orders.*) DESC
                                """;
                        List<Object[]> results = entityManager.createNativeQuery(query).getResultList();
                        results.forEach(row -> {
                            var firstName = (String) row[0];
                            var lastName = (String) row[1];
                            var total = (Long) row[2];
                            System.out.println(firstName + " " + lastName + " " + total);
                        });
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## Jakarta JPQL

                        JPQL is a query language that is very similar to SQL Native.
                        The main difference is that it is used to query entities and not tables.

                        Here is the same query as before, but using JPQL.

                        ```java
                        TypedQuery<Object[]> query = entityManager.createQuery("""
                                    SELECT persons.firstName, persons.lastName, COUNT(orders) AS total
                                    FROM persons persons
                                    JOIN persons.orders orders
                                    GROUP BY persons.firstName, persons.lastName
                                    ORDER BY COUNT(orders) DESC
                                """, Object[].class);
                        query.getResultList().forEach(row -> {
                            var firstName = (String) row[0];
                            var lastName = (String) row[1];
                            var total = (Long) row[2];
                            System.out.println(firstName + " " + lastName + " " + total);
                        });
                        ```
                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## Jakarta Named Queries

                        Named queries are a way to define JPQL queries in the entity class.

                        ```java
                        @Entity(name = "persons")
                        @NamedQueries({
                                @NamedQuery(name = "Person.findAll", query = "SELECT p FROM persons p"),
                                @NamedQuery(name = "Person.findById", query = "SELECT p FROM persons p WHERE p.id = :id")
                        })
                        public class Person {
                            //...
                        }
                        ```

                        ```java
                        TypedQuery<Person> query = entityManager.createNamedQuery("Person.findAll", Person.class);
                        List<Person> results = query.getResultList();
                
                        results.forEach(person -> {
                            System.out.println(person.getFirstName() + " " + person.getLastName());
                        });
                        ```
                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ##  Jakarta Criteria API

                        The Criteria API is a programmatic way to build queries.
                        Here is the same query as before, but using the Criteria API.

                        ```java
                        var cb = entityManager.getCriteriaBuilder();
                        var query = cb.createQuery(Object[].class);
                        var persons = query.from(Person.class);
                        var orders = persons.join("orders");
                        query.multiselect(persons.get("firstName"), persons.get("lastName"), cb.count(orders));
                        query.groupBy(persons.get("firstName"), persons.get("lastName"));
                        query.orderBy(cb.desc(cb.count(orders)));

                        entityManager.createQuery(query).getResultList().forEach(row -> {
                            var firstName = (String) row[0];
                            var lastName = (String) row[1];
                            var total = (Long) row[2];
                            System.out.println(firstName + " " + lastName + " " + total);
                        });
                        ```

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ##  Jakarta Criteria Metamodel

                        The Criteria Metamodel is another way to build queries programmatically.
                        Here is the same query as before, but using the Criteria Metamodel.

                        ```java       
                        var cb = entityManager.getCriteriaBuilder();
                        var query = cb.createQuery(Object[].class);
                        var persons = query.from(Person.class);
                        var orders = persons.join(Person_.orders);
                        query.multiselect(persons.get(Person_.firstName), persons.get(Person_.lastName), cb.count(orders));
                        query.groupBy(persons.get(Person_.firstName), persons.get(Person_.lastName));
                        query.orderBy(cb.desc(cb.count(orders)));

                        entityManager.createQuery(query).getResultList().forEach(row -> {
                            var firstName = (String) row[0];
                            var lastName = (String) row[1];
                            var total = (Long) row[2];
                            System.out.println(firstName + " " + lastName + " " + total);
                        });
                        ```

                        Note that the Criteria Metamodel is generated at compile time from the entities.
                        The main advantage of the Criteria Metamodel is that it is **type** and **refactoring safe**.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Lazy and eager loading

                        By default, JPA will **lazily load** the relationships of an entity.

                        - In other words, when loading an entity, JPA will not load its relationships. When accessing a relationship, JPA will load the relationship on demand.

                        In some cases, you may want to **eagerly load** the relationships of an entity.

                        - In other words, when loading an entity, JPA will load its relationships. This can be useful when you know that you will need the relationships.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Eager loading

                        Eager loading can be enabled on a relationship using the @ManyToOne(fetch = FetchType.EAGER) annotation.

                        ```java
                        @Entity(name = "orders")
                        public class Order {
                        
                            // ...
                        
                            @OneToMany(fetch = FetchType.EAGER)
                            @JoinColumn(name = "order_id", referencedColumnName = "id")
                            private List<OrderLine> orderLines;

                            // ...
                        }
                        ````

                        In this case, when loading an order, JPA will also load the person relationship.

                        Observe the effect of lazy and eager loading in the logs.

                        What could possibly go wrong if you always use eager loading?

                        
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> JPA EntityGraph

                        EntityGraph is an alternative to define a graph blueprint for fetching attributes and related entities. It allows you to specify which relationships should be fetched when loading an entity, it can dynamically applied to a retrieval
                        made by the EntityManager.

                        ```java
                        // Inside your repository or service class
                        public Actor getActorWithMovies(EntityManager entityManager, Long actorId) {
                            // Create an EntityGraph for the Actor entity
                            EntityGraph<Actor> entityGraph = entityManager.createEntityGraph(Actor.class);
                            
                            // Use the JPA Metamodel to refer to the "movies" attribute and add it to the fetch plan
                            entityGraph.addAttributeNodes(Actor_.movies);

                            // Use the EntityGraph when fetching the Actor
                            Map<String, Object> properties = new HashMap<>();
                            properties.put("javax.persistence.fetchgraph", entityGraph);

                            return entityManager.find(Actor.class, actorId, properties);
                        }
                        ```

                        EntityGraphes can also be declared using annotations, through `@NamedEntityGraph`.

                        Reference: [Jakarta 3.1, 3.7.4. Use of Entity Graphs in find and query operations](https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1#a2814)

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## Logging long running queries

                        In a framework, it is often hard to trace which high level operation is causing a long running query.

                        In Quarkus, you can enable the slow query logger to log queries that take more than a certain amount of time.

                        ```
                        quarkus.hibernate-orm.log.sql=true
                        quarkus.hibernate-orm.log.sql.max-query-time=1s
                        ```

                        This will log all queries that take more than 1 second to execute.
                        You can then analyze and optimize these queries using a database client.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## Optimizing long running queries

                        Using a database client (e.g. DataGrip or DBeaver), you can easily analyze the query plan of long running queries.

                        The EXPLAIN keyword will show you the query plan without executing the query.

                        ```SQL
                        EXPLAIN SELECT persons.first_name, persons.last_name, COUNT(orders.*) AS total
                        FROM persons
                        JOIN orders ON orders.person_id = persons.id
                        GROUP BY persons.first_name, persons.last_name
                        ORDER BY COUNT(orders.*) DESC
                        ```

                        The EXPLAIN ANALYZE keywords will show you the query plan and its actual execution time.

                    </textarea>
                </section>


                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## Understanding a query plan

                        In the query plan, you will see the following information:
                        - The order in which the tables are accessed
                        - The type of access (e.g. sequential scan, index scan, ...)
                        - The estimated cost of the operation (e.g. number of rows to read)
                        - The actual cost of the operation (e.g. number of rows to read)

                        Some operations, like sequential scan, are very expensive and should be avoided.
                        When joining tables, a sequential scan can result in the Cartesian product of the tables.

                        ```SQL
                        SELECT * FROM persons, orders WHERE persons.id = orders.person_id;
                        ```

                        Notes:
                        Here, if the person table has 1'000 rows and the orders table has 10'000 rows, the **Cartesian product** will have 10'000'000 rows.           
                        Without an index, the database will have to read all the rows of table1 and table2 to find the matching rows.
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## Indexing the database

                        When using SQL, you can add indexes to your tables.

                        ```SQL
                        CREATE INDEX person_first_name_index ON person (first_name);
                        ```
                            
                        When using JPA, you can also add indexes to your entities.

                        ```java
                        @Entity
                        @Table(name = "person")
                        @Index(name = "person_first_name_index", columnList = "first_name")
                        public class Person {
                            @Id
                            @GeneratedValue(strategy = GenerationType.IDENTITY)
                            private Long id;
                            private String firstName;
                            private String lastName;
                        }
                        ```
                    </textarea>
                </section>
            </section>

             <!-- Object relational impedance mismatch -->
             <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-database"></i> <br> Object relational <br> impedance mismatch </h2>
                </section>
                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Object relational impedance mismatch
                        
                        The object relational impedance mismatch is the difference between the object model and the relational model.

                        <img src="./images/object-relational-impedance-mismatch.png" alt="Object relational impedance mismatch" style="width: 50%;">

                        <span style="font-size: 0.3em;">Source https://martinfowler.com/bliki/OrmHate.html</span>
                        

                        Notes:
                        The object model has its roots in graph theory.

                        The relational model has its roots in set theory and the predicate logic.

                        source of the image: https://martinfowler.com/bliki/OrmHate.html


                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Object relational impedance mismatch

                        Some object oriented concepts do not exist in the relational model:
                        - Inheritance
                        - Polymorphism
                        - Encapsulation
                        - Identity
                        - Behavior
                        - etc.

                        Some relational concepts do not exist in the object model:
                        - Foreign keys
                        - Joins
                        - Indexes
                        - Transactions
                        - Aggregations
                        - etc.

                        These differences are hard to reconcile, and result in a so called impedance mismatch.


                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-database"></i> Object relational mapping (ORM)

                        **Object relational mapping (ORM)** is a technique that tries to address the object relational impedance mismatch.

                        The goal of an ORM is to **hide the differences** between the **object model** and the **relational model** as much as possible from the developer.

                        In practice, the ORM will **always leak** some relational concepts into the object model and vice versa.

                        Does it really matter?

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fas fa-hand-paper"></i> Better understand the discussion

                        Read the summary at the end of the article <a href="/references/031.01-Neward-The-Vietnam-of-Computer-Science-June-2006.pdf">The Vietnam of Computer Science</a> by Ted Neward.

                        Discuss with your neighbor and try to answer the following questions:
                        - What is the main argument of the article?
                        - Do you agree with the author?
                        - What is your opinion on the subject?

                    </textarea>
                </section>

            </section>

        </div>
    </div>
</body>
</html>