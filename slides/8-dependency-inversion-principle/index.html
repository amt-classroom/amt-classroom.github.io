<!doctype html>
<html lang="en">

<head>

    <meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Dependency inversion principle</title>

    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" crossorigin="anonymous">
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/theme/white.css" crossorigin="anonymous" id="theme">
    <script src="/node_modules/reveal.js/dist/reveal.js"></script>
    <script src="/node_modules/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="/node_modules/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="/node_modules/reveal.js/plugin/notes/notes.js"></script>
    <script src="/node_modules/reveal.js/plugin/search/search.js"></script>
    <script src="/slides/script.js" type="module"></script>
    <link rel="stylesheet" href="/css/solarized-light.css" />
    <link rel="stylesheet" href="/slides/style.css">

    <script src="/fontawesome-6.4.2/js/all.min.js"></script>
</head>

<body>

    <div class="reveal">
        <div class="slides">
            <!-- Title and outline -->
            <section data-background="#333333">
                <h2>AMT</h2>
                <h1><i class="fa-solid fa-music"></i> DIP, DI, IOC</i></h1>
                <p>Bertil Chapuis</p>      
            </section>
            <section data-markdown>
                <textarea data-template>
                    ## <i class="fas fa-tasks"></i> Overview of Today's Class
                    - Dependency inversion principle (DIP)
                    - Dependency injection (DI)
                    - Inversion of control (IoC)
                </textarea>
            </section>

            <!-- Dependency inversion principle (DIP) -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-diagram-project"></i> DIP</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> SOLID

                        The **SOLID** principles are a set of principles that help us design better software. They are:
                        - **S**ingle responsibility principle (SRP)
                        - **O**pen/closed principle (OCP)
                        - **L**iskov substitution principle (LSP)
                        - **I**nterface segregation principle (ISP)
                        - **D**ependency inversion principle (DIP)

                        The first four principles will not be discussed in this course.

                        The last principle is the one we will focus on today.

                        Notes:

                        **Single Responsibility Principle (SRP)**: A class should have only one reason to change - it should have only one job or responsibility.

                        **Open/Closed Principle (OCP)**: Software entities should be open for extension but closed for modification - you should be able to add new functionality without changing existing code.

                        **Liskov Substitution Principle (LSP)**: Objects of a superclass should be replaceable with objects of a subclass without breaking the application - subtypes must be substitutable for their base types.

                        **Interface Segregation Principle (ISP)**: Clients should not be forced to depend on interfaces they don't use - prefer many specific interfaces over one general-purpose interface.

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Dependency inversion principle (DIP)
                        
                        The **Dependency Inversion Principle (DIP)** states that:

                        - **High-level modules** should not depend on **low-level modules**. Both should depend on **abstractions**.
                        - **Abstractions** should not depend on **details**. Details should depend on abstractions.

                        By applying the DIP, we can **reduce the coupling** between modules and **increase their reusability**.

                        Notes:
                        - **High-level modules** are modules that provide the primary logic of the application.
                        - **Low-level modules** are modules that provide utility functions or basic infrastructure.
                        - **Abstractions** are interfaces or abstract classes.
                        - **Details** are concrete implementations of abstractions.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Why DIP Matters

                        **Without DIP:**
                        - High-level modules are tightly coupled to specific implementations
                        - Difficult to test (hard to mock dependencies)
                        - Hard to reuse modules in different contexts
                        - Changes to low-level modules require changes to high-level modules

                        **With DIP:**
                        - Modules depend on abstractions, not concrete implementations
                        - Easy to swap implementations (testing, different environments)
                        - High-level modules become reusable
                        - Changes to implementations don't affect high-level logic

                        Notes:
                        DIP is crucial for building maintainable, testable, and flexible applications.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Dependence between modules
                        
                        The following application has a **high-level module** that depends directly on a **low-level module**.


                        ```java
                        class ConsoleLogger {
                            public void logMessage(String message) {
                                System.out.println("Log message to console: " + message);
                            }
                        }
                        
                        class Application {
                        
                            // The high-level Application  depends directly on the low-level ConsoleLogger.
                            private ConsoleLogger logger = new ConsoleLogger();
                        
                            public void performOperation() {
                                logger.logMessage("Performing an operation");
                            }
                        }
                        
                        public class Main {
                        
                            public static void main(String[] args) {
                                Application app = new Application();
                                app.performOperation();
                            }
                        }
                        ```

                        Notes:

                        - It is not possible to reuse the **high-level module** in another application without also reusing the **low-level module**.

                        - It is not possible to replace the **low-level module** with another implementation without also changing the **high-level module**.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        <img src="/images/strong-dependency.png" alt="Strong dependency" style="width: 100%;">
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.5em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Applying the DIP
                        
                        The following application has a **high-level module** that depends on an **abstraction**.

                        ```java
                        // The Logger illustrates the dependency inversion principle (DIP), which corresponds to the "D" in the SOLID acronym.
                        interface Logger {
                            void logMessage(String message);
                        }

                        // The low-level ConsoleLogger implements the abstraction.
                        class ConsoleLogger implements Logger {
                            public void logMessage(String message) {
                                System.out.println("Log message to console: " + message);
                            }
                        }

                        class Application {

                            // The high-level Application now depends on the abstraction.
                            private Logger logger;

                            // The dependency is injected via the constructor.
                            public Application(Logger logger) {
                                this.logger = logger;
                            }

                            public void performOperation() {
                                logger.logMessage("Performing an operation");
                            }
                        }

                        public class Main {
                            public static void main(String[] args) {
                                Application app = new Application(new ConsoleLogger());
                                app.performOperation();
                            }
                        }
                        ```

                        Notes:

                        Thanks to the DIP:

                        - It is now possible to reuse the **high-level module** in another application without also reusing the **low-level module**.

                        - It is now possible to replace the **low-level module** with another implementation without also changing the **high-level module**.

                        Here, the dependencies are set programmatically via the constructor or a setter. 
                        It is not very practical when the graph of dependencies is large and complex.
 
                    </textarea>
                </section>
                
                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        <img src="/images/loose-dependency.png" alt="Strong dependency" style="width: 100%;">
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.5em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-hand-paper"></i> Exercise

                        Try to identify how the DIP approach is applied by the `java.sql` package (JDBC).

                        Identify the main abstraction, the high-level modules (i.e, abstractions) and the low-level 
                        modules (i.e, implementations).
                        A Quarkus project with a database can be used as an example.
 
                    </textarea>
                </section>

            </section>

            <!-- Dependency injection (DI) -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-diagram-project"></i> DI</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Dependency injection (DI)

                        **Dependency Injection (DI)** is the technique of supplying dependencies to a module from the outside, rather than having the module create them itself.

                        **Key roles in DI:**
                        - **Service**: The dependency being injected (e.g., a Logger)
                        - **Client**: The class that needs the dependency (e.g., Application)
                        - **Injector**: The code that provides the service to the client

                        **Three main injection approaches:**
                        - **Constructor injection**: Pass dependencies via constructor
                        - **Setter injection**: Pass dependencies via setter methods
                        - **Framework-based injection**: Use annotations and IoC containers

                        Notes:

                        DI is the primary technique for implementing the Dependency Inversion Principle (DIP).

                        By injecting dependencies from outside, we ensure that the client depends on an abstraction (interface) rather than a concrete implementation.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Constructor injection

                        ```java
                        class Application {
                            private final Logger logger;  // Can be final - immutable

                            // Dependencies are required at construction time
                            public Application(Logger logger) {
                                this.logger = logger;
                            }

                            public void performOperation() {
                                logger.logMessage("Performing operation");
                            }
                        }

                        // Usage: injector provides the dependency
                        Application app = new Application(new ConsoleLogger());
                        ```

                        **When to use:**
                        - For **required** dependencies (can't function without them)
                        - When you want **immutable** objects (thread-safe)
                        - Preferred approach in most cases

                        Notes:

                        Constructor injection makes dependencies explicit and ensures the object is always in a valid state.

                        The dependency can be marked `final`, which prevents it from being changed after construction (immutability).

                        This is the **recommended approach** for most dependencies.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Setter injection

                        ```java
                        class Application {
                            private Logger logger;  // Cannot be final - mutable

                            // Optional: can be set after construction
                            public void setLogger(Logger logger) {
                                this.logger = logger;
                            }

                            public void performOperation() {
                                if (logger != null) {  // Need to check for null
                                    logger.logMessage("Performing operation");
                                }
                            }
                        }

                        // Usage: injector sets dependency after creation
                        Application app = new Application();
                        app.setLogger(new ConsoleLogger());  // Can be changed later
                        ```

                        **When to use:**
                        - For **optional** dependencies (can work without them)
                        - When you need to **reconfigure** at runtime
                        - Less common than constructor injection

                        Notes:

                        Setter injection allows flexibility but introduces potential null pointer issues.

                        The object can exist in an incomplete state if the setter is never called.

                        Use this when you genuinely need runtime reconfiguration or optional dependencies.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Framework-based injection

                        **With frameworks** (e.g., Jakarta CDI, Spring), you declare dependencies using annotations:

                        ```java
                        interface Logger {
                            void logMessage(String message);
                        }

                        class Application {
                            // The framework will inject the dependency automatically
                            @Inject
                            private Logger logger;

                            public void performOperation() {
                                logger.logMessage("Performing an operation");
                            }
                        }

                        // Implementation is also registered with the framework
                        @ApplicationScoped
                        class ConsoleLogger implements Logger {
                            public void logMessage(String message) {
                                System.out.println("Log: " + message);
                            }
                        }
                        ```

                        Notes:

                        The framework (called an **IoC container**) manages the lifecycle of objects and their dependencies.

                        At runtime, the framework:
                        1. Scans for classes with annotations like @Inject
                        2. Creates instances of dependencies
                        3. Injects them into the client (typically using reflection)

                        This is called **interface injection** because the annotation acts as an interface to communicate with the framework.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Choosing the right injection approach

                        | Approach | Best for | Advantages | Drawbacks |
                        |----------|----------|------------|-----------|
                        | **Constructor** | Required dependencies | Immutable, always valid state | Can't reconfigure |
                        | **Setter** | Optional dependencies | Flexible, reconfigurable | Nullable, incomplete state |
                        | **Framework** | Enterprise apps | Automatic, manages lifecycle | Framework dependency |

                        **General recommendations:**
                        1. **Prefer constructor injection** for most dependencies
                        2. Use **setter injection** only for truly optional dependencies
                        3. Use **framework injection** in Jakarta EE / Quarkus applications

                        Notes:

                        Constructor injection is the safest choice because it guarantees that the object is always in a valid state.

                        Setter injection should be used sparingly, only when you genuinely need optional dependencies or runtime reconfiguration.

                        Framework-based injection is powerful but ties your code to a specific framework (though the annotations are standardized in Jakarta EE).

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Multiple Implementations: Using @Named

                        **Problem**: How do you inject a specific implementation when multiple classes implement the same interface?

                        **Solution**: Use `@Named` with string identifiers

                        ```java
                        interface Logger { void logMessage(String message); }

                        // Give each implementation a unique name
                        @Named("console")
                        @ApplicationScoped
                        class ConsoleLogger implements Logger {
                            public void logMessage(String msg) { System.out.println("Log: " + msg); }
                        }

                        @Named("file")
                        @ApplicationScoped
                        class FileLogger implements Logger {
                            public void logMessage(String msg) { /* write to file */ }
                        }

                        // Specify which implementation to inject
                        class Application {
                            @Inject @Named("console") Logger consoleLogger;
                            @Inject @Named("file") Logger fileLogger;
                        }
                        ```

                        **Pros**: Simple, quick to implement
                        
                        **Cons**: String typos only caught at runtime, no IDE autocomplete

                        Notes:

                        `@Named` is part of Jakarta Dependency Injection and works in all CDI containers.

                        The framework matches the string in `@Named` on the implementation with the string on the injection point.

                        This is the easiest approach for simple cases, but for larger codebases, custom qualifier annotations are preferred.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.55em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Multiple Implementations: Custom Qualifiers

                        **Alternative**: Create type-safe custom qualifier annotations

                        ```java
                        // Step 1: Define custom qualifier annotations
                        @Qualifier
                        @Retention(RUNTIME)
                        @Target({TYPE, METHOD, FIELD, PARAMETER})
                        public @interface Console {}

                        @Qualifier
                        @Retention(RUNTIME)
                        @Target({TYPE, METHOD, FIELD, PARAMETER})
                        public @interface File {}

                        // Step 2: Annotate implementations with custom qualifiers
                        @Console
                        @ApplicationScoped
                        class ConsoleLogger implements Logger {
                            public void logMessage(String msg) { System.out.println("Log: " + msg); }
                        }

                        @File
                        @ApplicationScoped
                        class FileLogger implements Logger {
                            public void logMessage(String msg) { /* write to file */ }
                        }

                        // Step 3: Use qualifiers for type-safe injection
                        class Application {
                            @Inject @Console Logger consoleLogger;  // Compile-time safe!
                            @Inject @File Logger fileLogger;
                        }
                        ```

                        **Pros**: Compile-time checking, IDE autocomplete, refactoring support

                        **Cons**: More verbose, requires creating annotation classes

                        Notes:

                        Custom qualifiers provide compile-time type safety that `@Named` cannot offer.

                        If you rename a qualifier annotation, the IDE will refactor all usages automatically.

                        The `@Qualifier` annotation marks your custom annotation as a CDI qualifier.

                        **Recommendation**: Use `@Named` for quick prototypes, custom qualifiers for production code.

                    </textarea>
                </section>

            </section>

            <!-- Inversion of control (IoC) -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-diagram-project"></i> IoC</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Inversion of control (IoC)
                        
                        **Inversion of control (IoC)** is a design principle that states that the control of the flow of a program is inverted.

                        - In a traditional program, the flow of the program is **controlled by the program** itself.

                        - In an IoC program, the flow of the program is **controlled by a framework**.

                        Notes:

                        **Constructor and setter injection** do not necessarily imply IoC.

                        **Interface injection** is a form of IoC among others.

                        In the java world, the term IoC is often used to refer to **interface injection**.

                        However, the scope of the term IoC is much broader than dependency injection, as the flow of the program is not limited to dependency instantiation and injection.

                        For instance, some MVC frameworks use IoC at the level of the HTTP router. They control the flow of the program based on the url and routing conventions.

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> How DIP, DI, and IoC Relate

                        These are three distinct but related concepts:

                        **DIP (Dependency Inversion Principle)**
                        - A design **principle**: "depend on abstractions, not concretions"
                        - **What** you should do to create flexible code

                        **DI (Dependency Injection)**
                        - A design **technique**: passing dependencies from outside
                        - **How** you implement DIP (constructor, setter, or framework-based)

                        **IoC (Inversion of Control)**
                        - A broader **architectural pattern**: framework controls the flow
                        - **Who** is in control (framework vs your code)
                        - DI with frameworks is one form of IoC

                        Notes:
                        Think of it this way: DIP tells you to depend on abstractions, DI is the technique to provide those abstractions from outside, and IoC containers are frameworks that automate DI for you.

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-hand-paper"></i> Jakarta, IoC and DIP

                        The main specification is Jakarta Contexts and Dependency Injection (CDI).
                        
                        https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0 

                        However the annotations, such as `jakarta.inject.Inject` or `jakarta.inject.Qualifier`, are defined by Jakarta Dependency Injection.
                        
                        https://jakarta.ee/specifications/dependency-injection/2.0/

                        In Quarkus, the dependency injection is provided by Quarkus ArC.

                        * https://quarkus.io/blog/quarkus-dependency-injection/
                        * https://quarkus.io/guides/cdi
                        * https://quarkus.io/guides/cdi-reference

                        Browse the above references and identify why RedHat, which is the main developer of Quarkus and
                        the reference implementation of Jakarta CDI (i.e, [Weld](http://weld.cdi-spec.org/)), decided
                        to develop Quarkus ArC.
                        
                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-hand-paper"></i> Example

                        Let's consider a more complete example!

                        https://github.com/amt-classroom/example-dipdiioc

                        Are we making simple things overly complex?

                        Discuss the pros and cons of DIP, DI and IoC.
                        
                    </textarea>
                </section>

            </section>

            <section>
                <h2><i class="fas fa-hand-paper"></i> Questions?</h2>
            </section>

        </div>
    </div>

</body>
</html>