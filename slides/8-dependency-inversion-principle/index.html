<!doctype html>
<html lang="en">

<head>

    <meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Dependency inversion principle</title>

    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" crossorigin="anonymous">
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/theme/white.css" crossorigin="anonymous" id="theme">
    <script src="/node_modules/reveal.js/dist/reveal.js"></script>
    <script src="/node_modules/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="/node_modules/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="/node_modules/reveal.js/plugin/notes/notes.js"></script>
    <script src="/node_modules/reveal.js/plugin/search/search.js"></script>
    <script src="/slides/script.js" type="module"></script>
    <link rel="stylesheet" href="/css/solarized-light.css" />
    <link rel="stylesheet" href="/slides/style.css">

    <script src="/fontawesome-6.4.2/js/all.min.js"></script>
</head>

<body>

    <div class="reveal">
        <div class="slides">
            <!-- Title and outline -->
            <section data-background="#333333">
                <h2>AMT</h2>
                <h1><i class="fa-solid fa-plug"></i> DIP, DI, IOC</i></h1>
                <p>Bertil Chapuis</p>
            </section>
            <section data-markdown>
                <textarea data-template>
                    ## <i class="fas fa-list-check"></i> Overview of Today's Class
                    - Dependency inversion principle (DIP)
                    - Dependency injection (DI)
                    - Inversion of control (IoC)
                </textarea>
            </section>

            <!-- Dependency inversion principle (DIP) -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-link"></i> DIP</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-link"></i> SOLID

                        The **SOLID** principles are a set of principles that help us design better software. They are:
                        - **S**ingle responsibility principle (SRP)
                        - **O**pen/closed principle (OCP)
                        - **L**iskov substitution principle (LSP)
                        - **I**nterface segregation principle (ISP)
                        - **D**ependency inversion principle (DIP)

                        The first four principles will not be discussed in this course.

                        The last principle is the one we will focus on today.

                        Notes:

                        **Single Responsibility Principle (SRP)**: A class should have only one reason to change - it should have only one job or responsibility.

                        **Open/Closed Principle (OCP)**: Software entities should be open for extension but closed for modification - you should be able to add new functionality without changing existing code.

                        **Liskov Substitution Principle (LSP)**: Objects of a superclass should be replaceable with objects of a subclass without breaking the application - subtypes must be substitutable for their base types.

                        **Interface Segregation Principle (ISP)**: Clients should not be forced to depend on interfaces they don't use - prefer many specific interfaces over one general-purpose interface.

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-link"></i> Dependency inversion principle (DIP)
                        
                        The **Dependency Inversion Principle (DIP)** states that:

                        - **High-level modules** should not depend on **low-level modules**. Both should depend on **abstractions**.
                        - **Abstractions** should not depend on **details**. Details should depend on abstractions.

                        By applying the DIP, we can **reduce the coupling** between modules and **increase their reusability**.

                        Notes:
                        - **High-level modules** are modules that provide the primary logic of the application.
                        - **Low-level modules** are modules that provide utility functions or basic infrastructure.
                        - **Abstractions** are interfaces or abstract classes.
                        - **Details** are concrete implementations of abstractions.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-lightbulb"></i> Why DIP Matters

                        **Without DIP:**
                        - High-level modules are tightly coupled to specific implementations
                        - Difficult to test (hard to mock dependencies)
                        - Hard to reuse modules in different contexts
                        - Changes to low-level modules require changes to high-level modules

                        **With DIP:**
                        - Modules depend on abstractions, not concrete implementations
                        - Easy to swap implementations (testing, different environments)
                        - High-level modules become reusable
                        - Changes to implementations don't affect high-level logic

                        Notes:
                        DIP is crucial for building maintainable, testable, and flexible applications.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-link"></i> Dependence between modules
                        
                        The following application has a **high-level module** that depends directly on a **low-level module**.


                        ```java
                        class ConsoleLogger {
                            public void logMessage(String message) {
                                System.out.println("Log message to console: " + message);
                            }
                        }
                        
                        class Application {
                        
                            // The high-level Application  depends directly on the low-level ConsoleLogger.
                            private ConsoleLogger logger = new ConsoleLogger();
                        
                            public void performOperation() {
                                logger.logMessage("Performing an operation");
                            }
                        }
                        
                        public class Main {
                        
                            public static void main(String[] args) {
                                Application app = new Application();
                                app.performOperation();
                            }
                        }
                        ```

                        Notes:

                        - It is not possible to reuse the **high-level module** in another application without also reusing the **low-level module**.

                        - It is not possible to replace the **low-level module** with another implementation without also changing the **high-level module**.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        <img src="/images/strong-dependency.png" alt="Strong dependency" style="width: 100%;">
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.5em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-link"></i> Applying the DIP
                        
                        The following application has a **high-level module** that depends on an **abstraction**.

                        ```java
                        // The Logger illustrates the dependency inversion principle (DIP), which corresponds to the "D" in the SOLID acronym.
                        interface Logger {
                            void logMessage(String message);
                        }

                        // The low-level ConsoleLogger implements the abstraction.
                        class ConsoleLogger implements Logger {
                            public void logMessage(String message) {
                                System.out.println("Log message to console: " + message);
                            }
                        }

                        class Application {

                            // The high-level Application now depends on the abstraction.
                            private Logger logger;

                            // The dependency is injected via the constructor.
                            public Application(Logger logger) {
                                this.logger = logger;
                            }

                            public void performOperation() {
                                logger.logMessage("Performing an operation");
                            }
                        }

                        public class Main {
                            public static void main(String[] args) {
                                Application app = new Application(new ConsoleLogger());
                                app.performOperation();
                            }
                        }
                        ```

                        Notes:

                        Thanks to the DIP:

                        - It is now possible to reuse the **high-level module** in another application without also reusing the **low-level module**.

                        - It is now possible to replace the **low-level module** with another implementation without also changing the **high-level module**.

                        Here, the dependencies are set programmatically via the constructor or a setter. 
                        It is not very practical when the graph of dependencies is large and complex.
 
                    </textarea>
                </section>
                
                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        <img src="/images/loose-dependency.png" alt="Strong dependency" style="width: 100%;">
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.5em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-graduation-cap"></i> Exercise

                        Try to identify how the DIP approach is applied by the `java.sql` package (JDBC).

                        Identify the main abstraction, the high-level modules (i.e, abstractions) and the low-level 
                        modules (i.e, implementations).
                        A Quarkus project with a database can be used as an example.
 
                    </textarea>
                </section>

            </section>

            <!-- Dependency injection (DI) -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-syringe"></i> DI</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-syringe"></i> Dependency injection (DI)

                        **Dependency Injection (DI)** is the technique of supplying dependencies to a module from the outside, rather than having the module create them itself.

                        **Key roles in DI:**
                        - **Service**: The dependency being injected (e.g., a Logger)
                        - **Client**: The class that needs the dependency (e.g., Application)
                        - **Injector**: The code that provides the service to the client

                        **Three main injection approaches:**
                        - **Constructor injection**: Pass dependencies via constructor
                        - **Setter injection**: Pass dependencies via setter methods
                        - **Framework-based injection**: Use annotations and IoC containers

                        Notes:

                        DI is the primary technique for implementing the Dependency Inversion Principle (DIP).

                        By injecting dependencies from outside, we ensure that the client depends on an abstraction (interface) rather than a concrete implementation.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-wrench"></i> Constructor injection

                        ```java
                        class Application {
                            private final Logger logger;  // Can be final - immutable

                            // Dependencies are required at construction time
                            public Application(Logger logger) {
                                this.logger = logger;
                            }

                            public void performOperation() {
                                logger.logMessage("Performing operation");
                            }
                        }

                        // Usage: injector provides the dependency
                        Application app = new Application(new ConsoleLogger());
                        ```

                        **When to use:**
                        - For **required** dependencies (can't function without them)
                        - When you want **immutable** objects (thread-safe)
                        - Preferred approach in most cases

                        Notes:

                        Constructor injection makes dependencies explicit and ensures the object is always in a valid state.

                        The dependency can be marked `final`, which prevents it from being changed after construction (immutability).

                        This is the **recommended approach** for most dependencies.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-sliders"></i> Setter injection

                        ```java
                        class Application {
                            private Logger logger;  // Cannot be final - mutable

                            // Optional: can be set after construction
                            public void setLogger(Logger logger) {
                                this.logger = logger;
                            }

                            public void performOperation() {
                                if (logger != null) {  // Need to check for null
                                    logger.logMessage("Performing operation");
                                }
                            }
                        }

                        // Usage: injector sets dependency after creation
                        Application app = new Application();
                        app.setLogger(new ConsoleLogger());  // Can be changed later
                        ```

                        **When to use:**
                        - For **optional** dependencies (can work without them)
                        - When you need to **reconfigure** at runtime
                        - Less common than constructor injection

                        Notes:

                        Setter injection allows flexibility but introduces potential null pointer issues.

                        The object can exist in an incomplete state if the setter is never called.

                        Use this when you genuinely need runtime reconfiguration or optional dependencies.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-gears"></i> Framework-based injection

                        **With frameworks** (e.g., Jakarta CDI, Spring), you declare dependencies using annotations:

                        ```java
                        interface Logger {
                            void logMessage(String message);
                        }

                        class Application {
                            // The framework will inject the dependency automatically
                            @Inject
                            private Logger logger;

                            public void performOperation() {
                                logger.logMessage("Performing an operation");
                            }
                        }

                        // Implementation is also registered with the framework
                        @ApplicationScoped
                        class ConsoleLogger implements Logger {
                            public void logMessage(String message) {
                                System.out.println("Log: " + message);
                            }
                        }
                        ```

                        Notes:

                        The framework (called an **IoC container**) manages the lifecycle of objects and their dependencies.

                        At runtime, the framework:
                        1. Scans for classes with annotations like @Inject
                        2. Creates instances of dependencies
                        3. Injects them into the client (typically using reflection)

                        This is called **interface injection** because the annotation acts as an interface to communicate with the framework.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-scale-balanced"></i> Choosing the right injection approach

                        | Approach | Best for | Advantages | Drawbacks |
                        |----------|----------|------------|-----------|
                        | **Constructor** | Required dependencies | Immutable, always valid state | Can't reconfigure |
                        | **Setter** | Optional dependencies | Flexible, reconfigurable | Nullable, incomplete state |
                        | **Framework** | Enterprise apps | Automatic, manages lifecycle | Framework dependency |

                        **General recommendations:**
                        1. **Prefer constructor injection** for most dependencies
                        2. Use **setter injection** only for truly optional dependencies
                        3. Use **framework injection** in Jakarta EE / Quarkus applications

                        Notes:

                        Constructor injection is the safest choice because it guarantees that the object is always in a valid state.

                        Setter injection should be used sparingly, only when you genuinely need optional dependencies or runtime reconfiguration.

                        Framework-based injection is powerful but ties your code to a specific framework (though the annotations are standardized in Jakarta EE).

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-layer-group"></i> Multiple Implementations: Using @Named

                        **Problem**: How do you inject a specific implementation when multiple classes implement the same interface?

                        **Solution**: Use `@Named` with string identifiers

                        ```java
                        interface Logger { void logMessage(String message); }

                        // Give each implementation a unique name
                        @Named("console")
                        @ApplicationScoped
                        class ConsoleLogger implements Logger {
                            public void logMessage(String msg) { System.out.println("Log: " + msg); }
                        }

                        @Named("file")
                        @ApplicationScoped
                        class FileLogger implements Logger {
                            public void logMessage(String msg) { /* write to file */ }
                        }

                        // Specify which implementation to inject
                        class Application {
                            @Inject @Named("console") Logger consoleLogger;
                            @Inject @Named("file") Logger fileLogger;
                        }
                        ```

                        **Pros**: Simple, quick to implement
                        
                        **Cons**: String typos only caught at runtime, no IDE autocomplete

                        Notes:

                        `@Named` is part of Jakarta Dependency Injection and works in all CDI containers.

                        The framework matches the string in `@Named` on the implementation with the string on the injection point.

                        This is the easiest approach for simple cases, but for larger codebases, custom qualifier annotations are preferred.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.55em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-layer-group"></i> Multiple Implementations: Custom Qualifiers

                        **Alternative**: Create type-safe custom qualifier annotations

                        ```java
                        // Step 1: Define custom qualifier annotations
                        @Qualifier
                        @Retention(RUNTIME)
                        @Target({TYPE, METHOD, FIELD, PARAMETER})
                        public @interface Console {}

                        @Qualifier
                        @Retention(RUNTIME)
                        @Target({TYPE, METHOD, FIELD, PARAMETER})
                        public @interface File {}

                        // Step 2: Annotate implementations with custom qualifiers
                        @Console
                        @ApplicationScoped
                        class ConsoleLogger implements Logger {
                            public void logMessage(String msg) { System.out.println("Log: " + msg); }
                        }

                        @File
                        @ApplicationScoped
                        class FileLogger implements Logger {
                            public void logMessage(String msg) { /* write to file */ }
                        }

                        // Step 3: Use qualifiers for type-safe injection
                        class Application {
                            @Inject @Console Logger consoleLogger;  // Compile-time safe!
                            @Inject @File Logger fileLogger;
                        }
                        ```

                        **Pros**: Compile-time checking, IDE autocomplete, refactoring support

                        **Cons**: More verbose, requires creating annotation classes

                        Notes:

                        Custom qualifiers provide compile-time type safety that `@Named` cannot offer.

                        If you rename a qualifier annotation, the IDE will refactor all usages automatically.

                        The `@Qualifier` annotation marks your custom annotation as a CDI qualifier.

                        **Recommendation**: Use `@Named` for quick prototypes, custom qualifiers for production code.

                    </textarea>
                </section>

            </section>

            <!-- Inversion of control (IoC) -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-rotate"></i> IoC</h2>
                </section>
                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-rotate"></i> Inversion of control (IoC)

                        **Inversion of Control (IoC)** is a design principle where the framework calls your code, instead of your code calling the framework.

                        **Traditional control flow** (you call the library):
                        ```java
                        public static void main(String[] args) {
                            Logger logger = new ConsoleLogger();      // You create objects
                            Application app = new Application(logger); // You control construction
                            app.performOperation();                    // You call methods
                        }
                        ```

                        **Inverted control flow** (framework calls you):
                        ```java
                        @ApplicationScoped
                        class Application {
                            @Inject Logger logger;  // Framework creates and injects

                            @GET @Path("/api/operation")  // Framework calls your method
                            public void performOperation() { /* your code */ }
                        }
                        ```

                        **The "Hollywood Principle"**: *"Don't call us, we'll call you"*

                        Notes:

                        IoC is broader than just dependency injection. Examples of IoC include:
                        - **Dependency Management**: Framework creates and injects dependencies (CDI, Spring)
                        - **Request Routing**: Framework calls your handlers based on URLs (JAX-RS, Servlets)
                        - **Lifecycle Management**: Framework controls when objects are created/destroyed
                        - **Event Handling**: Framework calls your listeners when events occur

                        The key insight: You give up control to the framework, which provides infrastructure services.

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-circle-nodes"></i> IoC Container Lifecycle

                        An **IoC Container** manages the complete lifecycle of your objects:

                        ```java
                        // 1. Application Startup - Container scans for beans
                        @ApplicationScoped
                        class EmailService { /* ... */ }

                        @ApplicationScoped
                        class UserService {
                            @Inject EmailService emailService;  // Container will inject this
                        }

                        // 2. Container creates a dependency graph
                        // EmailService has no dependencies → create it first
                        // UserService depends on EmailService → inject EmailService → create UserService

                        // 3. Container manages scopes and lifecycle
                        @RequestScoped      // New instance per HTTP request
                        @SessionScoped      // One instance per user session
                        @ApplicationScoped  // Single instance for entire application

                        // 4. Your code uses the beans - framework calls you
                        @Path("/users")
                        class UserResource {
                            @Inject UserService userService;  // Container provides this

                            @POST
                            public void createUser(User user) {  // Framework calls this method
                                userService.save(user);
                            }
                        }

                        // 5. Application Shutdown - Container destroys beans in correct order
                        ```

                        Notes:

                        The IoC container provides:
                        - **Automatic dependency resolution**: Analyzes @Inject and creates dependency graph
                        - **Scope management**: Controls when objects are created and destroyed
                        - **Lifecycle hooks**: @PostConstruct, @PreDestroy for initialization/cleanup
                        - **Thread safety**: Manages concurrent access to shared beans

                        This is much more than just "dependency injection" - it's infrastructure management.

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-sitemap"></i> How DIP, DI, and IoC Relate

                        These are three distinct but related concepts:

                        **DIP (Dependency Inversion Principle)**
                        - A design **principle**: "depend on abstractions, not concretions"
                        - **What** you should do to create flexible code

                        **DI (Dependency Injection)**
                        - A design **technique**: passing dependencies from outside
                        - **How** you implement DIP (constructor, setter, or framework-based)

                        **IoC (Inversion of Control)**
                        - A broader **architectural pattern**: framework controls the flow
                        - **Who** is in control (framework vs your code)
                        - DI with frameworks is one form of IoC

                        Notes:
                        Think of it this way: DIP tells you to depend on abstractions, DI is the technique to provide those abstractions from outside, and IoC containers are frameworks that automate DI for you.

                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-cube"></i> Jakarta CDI Ecosystem

                        **Jakarta EE** provides standardized specifications for enterprise Java:

                        **Jakarta Dependency Injection** (JSR-330)
                        - Defines basic annotations: `@Inject`, `@Qualifier`, `@Named`, `@Singleton`
                        - Specification: https://jakarta.ee/specifications/dependency-injection/2.0/

                        **Jakarta Contexts and Dependency Injection (CDI)**
                        - Extends Dependency Injection with more features: scopes, events, interceptors
                        - Adds: `@ApplicationScoped`, `@RequestScoped`, `@PostConstruct`, etc.
                        - Specification: https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0

                        **Implementations:**
                        - **Weld**: Reference implementation (full Jakarta EE)
                        - **Quarkus ArC**: Optimized implementation for Quarkus (build-time DI)

                        **Why Quarkus ArC instead of Weld?**
                        - Look at the Quarkus documentation and discuss with other students.


                        Notes:

                        The Jakarta ecosystem separates concerns:
                        - **Dependency Injection** defines the minimal DI API (like an interface)
                        - **CDI** extends it with enterprise features (like a rich implementation)

                        Quarkus ArC is a compile-time CDI implementation that trades some runtime flexibility for better performance. It's perfect for microservices where fast startup matters.

                        **Additional resources:**
                        - [Quarkus DI Blog](https://quarkus.io/blog/quarkus-dependency-injection/)
                        - [Quarkus CDI Guide](https://quarkus.io/guides/cdi)


                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-comments"></i> Practical Example & Discussion

                        **Complete example**: https://github.com/amt-classroom/example-dipdiioc

                        **Discussion questions:**

                        **1. Complexity vs Benefits**
                        - Are we making simple things overly complex?
                        - When is manual DI sufficient? When do you need an IoC container?

                        **2. Testability**
                        - How does DIP make unit testing easier?
                        - Compare testing with and without dependency injection

                        **3. Trade-offs**
                        - **Pros**: Loose coupling, testability, flexibility, standardization
                        - **Cons**: Learning curve, runtime overhead, debugging complexity, magic behavior

                        **4. Real-world scenarios**
                        - When would you avoid using DI frameworks?
                        - What problems do CDI scopes (`@RequestScoped`, `@ApplicationScoped`) solve?

                        Notes:

                        Good discussions points:
                        - Small applications might not need IoC containers - manual DI is fine
                        - Large applications benefit greatly from standardized DI (easier onboarding)
                        - Test frameworks can mock dependencies easily when using DI
                        - Understanding the "magic" requires learning the framework
                        - Debugging can be harder when you don't control object creation

                    </textarea>
                </section>

            </section>

            <section>
                <h2><i class="fas fa-circle-question"></i> Questions?</h2>
            </section>

        </div>
    </div>

</body>
</html>