<!doctype html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Dependency injection and mocking</title>

    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" crossorigin="anonymous">
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/theme/white.css" crossorigin="anonymous" id="theme">
    <script src="/node_modules/reveal.js/dist/reveal.js"></script>
    <script src="/node_modules/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="/node_modules/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="/node_modules/reveal.js/plugin/notes/notes.js"></script>
    <script src="/node_modules/reveal.js/plugin/search/search.js"></script>
    <script src="/slides/script.js" type="module"></script>
    <link rel="stylesheet" href="/css/solarized-light.css" />
    <link rel="stylesheet" href="/slides/style.css">


    <script src="/fontawesome-6.4.2/js/all.min.js"></script>
</head>

<body>

    <div class="reveal">
        <div class="slides">
            <!-- Title and outline -->
            <section data-background="#333333">
                <h2>AMT</h2>
                <h1>Dependency injection and mocking</h1>
                <p>Bertil Chapuis</p>
            </section>
            <section data-markdown>
                <textarea data-template>
                    ## <i class="fas fa-list-check"></i> Overview of Today's Class
                    - Dependency Injection with Jakarta CDI
                    - Testing with Stubs and Mocks
                    - Testing CDI Applications

                </textarea>
            </section>

            <!-- Dependency Injection -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-diagram-project"></i> Jakarta CDI</h2>
                </section>
                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Jakarta CDI
                        
                        Recall that Dependency Injection (DI) and Inversion of Control (IoC) are closely related concepts that promote modularity and testability.

                        **Jakarta Context and Dependency Injection** is a specification for DI and IoC in Jakarta EE applications.

                        Runtimes that implement this specification manage the creation and injection of dependencies and their **lifecycle**.

                    </textarea>
                </section>

                <!-- Slide 4: Advantages & Use-Cases -->
                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Some advantages of Jakarta CDI
            
                        Jakarta CDI provides the following advantages:

                        - Unopinionated and flexible.
                        - Independence from the runtime.
                        - Enhanced modularity.
                        - Improved testability.
                        - Clearer and well organized code.
                        - Etc.

                        As for the JPA specification, some developers criticize Jakarta CDI for being too complex and verbose.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Core concepts of Jakarta CDI

                        Last week, we examined a toy runtime supporting the @Inject annotation.

                        Jakarta CDI is a more complex specification that introduces the following concepts:
                        - Beans
                        - Scopes
                        - Producers
                        - Qualifiers
                        - Lifecycle
                        - Interceptors
                        - Decorators
                        - Events and Observers
                        - Etc.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-syringe"></i> Injection with @Inject

                        The `@Inject` annotation marks where dependencies should be injected. Three approaches exist:

                        ```java
                        @ApplicationScoped
                        public class GreetingService {

                            // Field injection: simple but harder to test
                            @Inject
                            HelloService helloService;

                            // Constructor injection: preferred, explicit dependencies
                            private final GoodbyeService goodbyeService;

                            @Inject
                            public GreetingService(GoodbyeService goodbyeService) {
                                this.goodbyeService = goodbyeService;
                            }

                            // Method injection: useful for optional dependencies
                            private LogService logService;

                            @Inject
                            public void setLogService(LogService logService) {
                                this.logService = logService;
                            }
                        }
                        ```

                        Constructor injection is preferred for required dependencies as it makes them immutable and testable.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-diagram-project"></i> Beans

                        A **bean** is a class that is managed by the runtime.
                    
                        It should not be confused with the JavaBean specification.

                        An instance of a bean is called a **managed instance**.

                        Notes:

                        Do not confuse the term "bean" with the JavaBean specification.

                        A bean is a class that is managed by the runtime.

                        A managed instance is an instance of a bean.

                        Sometimes, the term "CDI bean" is used to distinguish beans from JavaBeans and Enterprise JavaBeans.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-clock"></i> Scopes

                        A **scope** defines the lifecycle of a **managed instance**.

                        The following scopes are defined by the specification:
                        - `@ApplicationScoped`: one instance per application.
                        - `@SessionScoped`: one instance per session.
                        - `@RequestScoped`: one instance per request.
                        - `@Dependent`: one instance per injection point (default scope).

                        Managed instances are usually created **lazily** (i.e., when they are first injected) and destroyed when the scope ends.
                        In general, managed instances are exposed as **proxies** (i.e., the runtime injects a proxy instead of the actual instance).

                        - `@Singleton`: similar to `@ApplicationScoped`, but the instance is created **eagerly** (i.e., when the application starts) and is not exposed as a proxy.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-clock"></i> Scopes

                        The following code snippet illustrates the use of the @ApplicationScoped scope.

                        ```java
                        @ApplicationScoped
                        public class HelloService {
                            
                            public String sayHello() {
                                return "Hello!";
                            }
                        }
                        ```

                        Here, the runtime will create a single managed instance of the HelloService class and inject it whenever it is requested.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.55em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-clock"></i> Choosing the Right Scope

                        | Scope | Lifecycle | Proxy | Use Case |
                        |-------|-----------|-------|----------|
                        | `@ApplicationScoped` | One per app | Yes | Services, configurations, caches |
                        | `@SessionScoped` | One per HTTP session | Yes | User preferences, shopping cart |
                        | `@RequestScoped` | One per HTTP request | Yes | Request-specific data, transactions |
                        | `@Dependent` | One per injection point | No | Stateless helpers, default scope |
                        | `@Singleton` | One per app (eager) | No | App-wide state, no proxy overhead |

                        **Decision guide:**
                        - Need shared state across requests? → `@ApplicationScoped`
                        - User-specific data? → `@SessionScoped`
                        - Request-specific isolation? → `@RequestScoped`
                        - No shared state needed? → `@Dependent`
                        - Need eager initialization or direct reference? → `@Singleton`

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-industry"></i> Producers and Qualifiers

                        The `@Produces` annotation can be used to define a **producer**.
                        - It can be used on a method or a field.
                        - Ambiguities arise when more than one producer is available for a given type.

                        Qualifiers can be used to disambiguate producers.
                        - The `@Named` annotation associates a name with a producer.
                        - It can be used to distinguish between producers of the same type.

                        Other qualifiers, such as `@Default` or `@Alternative`, are defined by the specification.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-industry"></i> Producers and Qualifiers

                        The following code snippet illustrates the use of a producer with a qualifier.

                        ```java
                        @ApplicationScoped
                        public class Producers {
                            @Produces
                            @Named("name")
                            public String name() {
                                return "Edouard";
                            }
                        }

                        @ApplicationScoped
                        public class HelloService {
                            @Inject
                            @Named("name")
                            private String name;

                            public String sayHello() {
                                return "Hello " + name + "!";
                            }
                        }
                        ```

                        Here, the runtime will inject the String "Edouard" into the HelloService class.
                        The `@Named` annotation is a **qualifier** that uses a String to disambiguate producers of the same type.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-industry"></i> Producers and Qualifiers

                        The developer can define custom qualifiers by using the `@Qualifier` annotation.

                        ```java
                        @Qualifier
                        @Retention(RetentionPolicy.RUNTIME)
                        @Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE})
                        public @interface Name {
                        }

                        @ApplicationScoped
                        public class NameProducer {
                            @Produces
                            @Name
                            public String name() {
                                return "Edouard";
                            }
                        }

                        @ApplicationScoped
                        public class HelloService {
                            @Inject
                            @Name
                            private String name;
                            public String sayHello() {
                                return "Hello " + name + "!";
                            }
                        }
                        ```

                        Here, the runtime will inject the String "Edouard" into the HelloService class thanks to the custom `@Name` qualifier.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-magnifying-glass"></i> Programmatic Lookup with Instance

                        Sometimes dependencies need to be resolved **dynamically** at runtime. The `Instance<T>` interface provides programmatic lookup:

                        ```java
                        @ApplicationScoped
                        public class PaymentProcessor {

                            @Inject
                            Instance&lt;PaymentGateway&gt; gateways;  // All implementations

                            @Inject
                            @CreditCard
                            Instance&lt;PaymentGateway&gt; creditCardGateway;  // Specific one

                            public void process(Payment payment) {
                                // Iterate over all available implementations
                                for (PaymentGateway gateway : gateways) {
                                    if (gateway.supports(payment)) {
                                        gateway.process(payment);
                                        return;
                                    }
                                }

                                // Or get a specific instance
                                if (creditCardGateway.isResolvable()) {
                                    creditCardGateway.get().process(payment);
                                }
                            }
                        }
                        ```

                        Useful for: plugin systems, strategy patterns, optional dependencies.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-heart-pulse"></i> Lifecycle

                        The lifecycle of a managed instance is defined by the [Contextual](https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#contextual) interface.

                        The following annotations can be used to define methods that are called when the corresponding event occurs:
                        - `@PostConstruct`: the method is called after the initialization of the managed instance.
                        - `@PreDestroy`: the method is called before the destruction of the managed instance.
                        


                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-heart-pulse"></i> Lifecycle

                        The following code snippet illustrates the use of lifecycle annotations.

                        ```java
                        @ApplicationScoped
                        public class HelloService {

                            @PostConstruct
                            public void init() {
                                System.out.println("The managed instance is initialized.");
                            }
                            
                            public String sayHello() {
                                return "Hello World!";
                            }
                        }
                        ```

                        Here, the runtime will call the `init()` method after the instantiation and injection of the managed instance.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-filter"></i> Interceptors

                        An **interceptor** is a class that can intercept the execution of a method.

                        The following annotations can be used to define an interceptor:
                        - `@InterceptorBinding`: defines an interceptor binding.
                        - `@Interceptor`: marks the class as an interceptor.
                        - `@AroundInvoke`: the method is called around the execution of a method.
                        - `@AroundConstruct`: the method is called around the instantiation of a managed instance.

                        Interceptors are used to implement cross-cutting concerns such as logging, security, etc.

                        They should not be used for business logic.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-filter"></i> Interceptors

                        The following code snippet illustrates the use of interceptors to create a binding and use it to intercept the execution of a method.

                        ```java
                        @InterceptorBinding
                        @Retention(RetentionPolicy.RUNTIME)
                        @Target({ElementType.METHOD, ElementType.TYPE})
                        public @interface Logged {
                        }

                        @Interceptor
                        @Logged
                        public class LoggedInterceptor {
                            @AroundInvoke
                            public Object log(InvocationContext context) throws Exception {
                                System.out.println("Before method " + context.getMethod().getName());
                                Object result = context.proceed();
                                System.out.println("After method " + context.getMethod().getName());
                                return result;
                            }
                        }

                        @ApplicationScoped
                        @Logged
                        public class HelloService {
                            public String sayHello() {
                                return "Hello World!";
                            }
                        }
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-gift"></i> Decorators

                        A **decorator** is a class that can decorate the behavior of a managed instance.
                        
                        The following annotations can be used to define a decorator:
                        - `@Decorator`: marks a class as a decorator.
                        - `@Delegate` and `@Inject`: injects the decorated instance into a field.
                        - `@Priority`: defines the priority of the decorator (smaller values have higher priority).

                        Decorators implement the interface of the decorated instance and can add behavior without modifying its code.

                        Unlike interceptors, they can be used for business logic.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-gift"></i> Decorators

                        The following code snippet illustrates the use of decorators.

                        ```java
                        @Decorator
                        public class HelloDecorator implements HelloService {
                            @Inject
                            @Delegate
                            private HelloService helloService;
                            @Override
                            public String sayHello() {
                                return helloService.sayHello() + " from decorator!";
                            }
                        }

                        public interface HelloService {
                            String sayHello();
                        }

                        @ApplicationScoped
                        public class HelloServiceImpl implements HelloService {
                            public String sayHello() {
                                return "Hello World!";
                            }
                        }

                        @ApplicationScoped
                        public class HelloTrigger {
                            @Inject
                            private HelloService helloService;
                            public void sayHello() {
                                System.out.println(helloService.sayHello());
                            }
                        }
                        ```


                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-bell"></i> Events and Observers

                        The **event** mechanism allows managed instances to communicate without coupling them.
                        - The `Event` class is used to define and fire events.
                        - The `@Observes` annotation defines an **observer** method that is called when an event is fired.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.75em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-bell"></i> Events and Observers

                        The following code snippet illustrates the use of events and observers.

                        ```java
                        @ApplicationScoped
                        public class HelloTrigger {
                            @Inject
                            private Event<String> event;

                            public void sayHello() {
                                event.fire("Hello World!");
                            }
                        }

                        @ApplicationScoped
                        public class HelloObserver {
                            public void observe(@Observes String message) {
                                System.out.println(message);
                            }
                        }
                        ```

                        The event can be of any type, and the observer method can have any name.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-bell"></i> Advanced Events

                        **Asynchronous events** allow non-blocking event processing:

                        ```java
                        @ApplicationScoped
                        public class OrderService {
                            @Inject
                            Event&lt;OrderPlaced&gt; orderEvent;

                            public void placeOrder(Order order) {
                                // Fire asynchronously - returns immediately
                                orderEvent.fireAsync(new OrderPlaced(order))
                                    .thenAccept(event -> log.info("Order processed"));
                            }
                        }

                        @ApplicationScoped
                        public class EmailNotifier {
                            public void onOrderPlaced(@ObservesAsync OrderPlaced event) {
                                // Executed in a separate thread
                                sendEmail(event.getOrder().getCustomerEmail());
                            }
                        }
                        ```

                        **Event qualifiers** allow selective observation:

                        ```java
                        @Inject @Priority(HIGH) Event&lt;Alert&gt; highPriorityAlert;

                        public void onHighAlert(@Observes @Priority(HIGH) Alert alert) { ... }
                        ```

                    </textarea>
                </section>
            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-vial-circle-check"></i> Testing with Stubs and Mocks</h2>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-link"></i> Why DI Enables Better Testing

                        Dependency Injection makes code **testable by design**.

                        **Without DI** (hard to test):
                        ```java
                        public class OrderService {
                            private EmailService email = new EmailService(); // Tight coupling
                            private PaymentGateway payment = new StripeGateway(); // Real API!
                        }
                        ```

                        **With DI** (easy to test):
                        ```java
                        public class OrderService {
                            @Inject EmailService email;      // Can inject a mock
                            @Inject PaymentGateway payment;  // Can inject a fake
                        }
                        ```

                        DI allows **swapping real dependencies with test doubles** (stubs, mocks, fakes) without changing the class under test.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-book-open"></i> Key Concepts and Definitions
                
                        - The **class under test** is the primary class being tested.
                        - A **dependency** is a class that the class under test relies on.
                        - **Unit tests** verify the **behavior** and **interactions** of the class under test.
                        - A **stub** is a simplified replacement that returns controlled values for testing the **behavior** of the class under test in isolation.
                        - A **mock** is a replacement that enables verification of the **interactions** between the class under test and its dependencies.
                        - The **AAA pattern** is a common structure for unit tests:
                          - **Arrange**: set up the necessary objects and state.
                          - **Act**: invoke the method to be tested.
                          - **Assert**: verify the outcome matches expectations.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-scale-balanced"></i> Stub vs Mock: When to Use Which?

                        | Aspect | Stub | Mock |
                        |--------|------|------|
                        | **Purpose** | Provide canned answers | Verify interactions |
                        | **Focus** | State/behavior of class under test | Communication with dependencies |
                        | **Assertion** | On return values | On method calls |
                        | **Complexity** | Simpler | More complex |

                        **Use a stub when:**
                        - You need controlled return values from dependencies.
                        - Testing the **output** or **state** of the class under test.
                        - The dependency is a data source (repository, API client).

                        **Use a mock when:**
                        - You need to verify a method was called (and how).
                        - Testing **side effects** (emails sent, logs written).
                        - The dependency performs actions but does not return meaningful data.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 1em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-vial-circle-check"></i> Stubbing

                        **Stubbing** is a technique used to replace a dependency with a **stub**.

                        A **stub** is a simple implementation that returns predefined values.

                        Stubbing isolates the **behavior** of the class under test by controlling its dependencies.

                        When testing, focus on verifying the **behavior of the class**, not the stub.
                  
                    </textarea>
                </section>
                <section data-markdown style="font-size: 0.8em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-vial-circle-check"></i> Stubbing

                        The following code snippet illustrates the use of a stub to test the behavior of a class in **isolation**.

                        ```java
                        public class GreetingService {
                            private final HelloService helloService;
                            public GreetingService(HelloService helloService) {
                                this.helloService = helloService;
                            }
                            public String generateGreeting(String name) {
                                return helloService.sayHello() + ", " + name + "!";
                            }
                        }

                        @Test
                        public void testGreetingService() {
                            HelloService helloService = Mockito.mock(HelloService.class);
                            Mockito.when(helloService.sayHello()).thenReturn("Hello");
                            GreetingService greetingService = new GreetingService(helloService);
                            String result = greetingService.generateGreeting("John");
                            assertEquals("Hello, John!", result);
                        }
                        ```

                        This example tests the **behavior of the `GreetingService`** class in isolation by stubbing the `HelloService` dependency.
                  
                    </textarea>
                </section>

                <section data-markdown style="font-size: 1em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                            ## <i class="fa-solid fa-vial-circle-check"></i> Mocking
    
                            **Mocking** is a technique used to replace a dependency with a **mock**.

                            A **mock** is an implementation that allows verification of interactions.

                            Mocking tests the **interactions** between a class and its dependencies, ensuring the class behaves as expected.

                            It focuses on the **class under test** and validates its communication with dependencies.
    
                        </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                            ## <i class="fa-solid fa-vial-circle-check"></i> Mocking

                            The following code snippet illustrates the use of a mock to test the interactions between a class and its dependencies with JUnit and Mockito.

                            ```java
                            public class NotificationService {
                                private final EmailSender emailSender;
                                public NotificationService(EmailSender emailSender) {
                                    this.emailSender = emailSender;
                                }
                                public void sendWelcomeEmail(String email) {
                                    emailSender.sendEmail(email, "Welcome", "Thank you for signing up!");
                                }
                            }

                            @Test
                            public void testNotificationServiceInteractions() {
                                EmailSender emailSender = Mockito.mock(EmailSender.class);
                                NotificationService notificationService = new NotificationService(emailSender);
                                notificationService.sendWelcomeEmail("user@example.com");
                                Mockito.verify(emailSender).sendEmail(
                                    "user@example.com", 
                                    "Welcome", 
                                    "Thank you for signing up!"
                                );
                            }
                            ```

                            This test verifies that the `NotificationService` class correctly interacts with the mocked `EmailSender` dependency.
    
                        </textarea>
                </section>


                <section data-markdown style="font-size: 1em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-wand-magic-sparkles"></i> Mockito

                        Mockito is a popular mocking framework for Java that simplifies the creation of mocks and the verification of interactions.

                        Check out the [Mockito documentation](https://site.mockito.org/), the [Baeldung Mockito Series](https://www.baeldung.com/mockito-series), and the [Mockito example](https://github.com/amt-classroom/example-mockito) for more information.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-at"></i> Mockito Annotations

                        Annotations make tests cleaner and more readable:

                        ```java
                        @ExtendWith(MockitoExtension.class) // JUnit 5 integration
                        class OrderServiceTest {

                            @Mock // Creates a mock
                            private PaymentGateway paymentGateway;

                            @Mock
                            private EmailService emailService;

                            @InjectMocks // Creates instance and injects mocks
                            private OrderService orderService;

                            @Captor // Captures arguments for inspection
                            private ArgumentCaptor&lt;Email&gt; emailCaptor;

                            @Test
                            void shouldSendConfirmationEmail() {
                                orderService.processOrder(new Order("item", 100));

                                verify(emailService).send(emailCaptor.capture());
                                assertEquals("Order Confirmation", emailCaptor.getValue().getSubject());
                            }
                        }
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-asterisk"></i> Argument Matchers

                        When exact argument values do not matter, use **matchers**:

                        ```java
                        // Match any value of a type
                        when(repository.findById(anyLong())).thenReturn(Optional.of(user));
                        when(service.process(anyString(), anyInt())).thenReturn(result);

                        // Match specific conditions
                        when(validator.validate(argThat(user -> user.getAge() >= 18)))
                            .thenReturn(true);

                        // Match null or non-null
                        when(service.save(isNull())).thenThrow(new IllegalArgumentException());
                        when(service.save(notNull())).thenReturn(saved);

                        // Combine with eq() for exact matches
                        when(service.find(eq("admin"), anyInt())).thenReturn(admin);
                        ```

                        **Important**: If you use a matcher for one argument, you must use matchers for **all** arguments:
                        ```java
                        // WRONG: when(service.find("admin", anyInt()))
                        // RIGHT: when(service.find(eq("admin"), anyInt()))
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-user-secret"></i> Spies: Partial Mocking

                        A **spy** wraps a real object, allowing specific methods to be stubbed while keeping others:

                        ```java
                        @Spy
                        private List&lt;String&gt; spyList = new ArrayList&lt;&gt;();

                        @Test
                        void spyExample() {
                            // Real method is called
                            spyList.add("one");
                            spyList.add("two");
                            assertEquals(2, spyList.size());  // Real size

                            // Stub specific method
                            doReturn(100).when(spyList).size();
                            assertEquals(100, spyList.size());  // Stubbed!

                            // Real list still has 2 elements
                            assertEquals("one", spyList.get(0));
                        }
                        ```

                        **When to use spies:**
                        - Testing legacy code that cannot be easily refactored.
                        - When most of the real behavior is needed but one method should be overridden.
                        - **Avoid when possible**: prefer full mocks with proper DI.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-check-double"></i> Verification Options

                        Mockito provides flexible verification of method calls:

                        ```java
                        // Verify exact number of calls
                        verify(emailService, times(3)).send(any());
                        verify(emailService, times(1)).send(any());  // same as verify(...)

                        // Verify never called
                        verify(paymentGateway, never()).refund(any());

                        // Verify at least / at most
                        verify(logger, atLeastOnce()).log(any());
                        verify(logger, atLeast(2)).log(any());
                        verify(logger, atMost(5)).log(any());

                        // Verify call order
                        InOrder inOrder = inOrder(validator, repository, emailService);
                        inOrder.verify(validator).validate(any());
                        inOrder.verify(repository).save(any());
                        inOrder.verify(emailService).send(any());

                        // Verify no more interactions
                        verifyNoMoreInteractions(emailService);
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-bomb"></i> Stubbing Exceptions

                        Test error handling by making mocks throw exceptions:

                        ```java
                        @Test
                        void shouldHandlePaymentFailure() {
                            // Stub to throw exception
                            when(paymentGateway.charge(any()))
                                .thenThrow(new PaymentException("Card declined"));

                            // Verify exception is handled correctly
                            assertThrows(OrderException.class,
                                () -> orderService.processOrder(order));

                            // Verify rollback was called
                            verify(repository).rollback(order);
                        }

                        @Test
                        void shouldRetryOnTimeout() {
                            // First call fails, second succeeds
                            when(apiClient.fetch(any()))
                                .thenThrow(new TimeoutException())
                                .thenReturn(response);

                            Result result = service.fetchWithRetry();

                            assertEquals(response, result);
                            verify(apiClient, times(2)).fetch(any());
                        }
                        ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.65em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-triangle-exclamation"></i> Mocking Best Practices

                        **Do:**
                        - Mock external dependencies (APIs, databases, file systems).
                        - Keep mocks simple: complex mock setups are a code smell.
                        - Use constructor injection for easier testing.
                        - Verify only meaningful interactions.

                        **Do not:**
                        - Mock value objects or data classes.
                        - Mock the class under test.
                        - Over-verify: not every call needs verification.
                        - Create mocks that return mocks (mock chains).

                        **Warning signs tests may be too coupled to implementation:**
                        - Tests break when refactoring without changing behavior.
                        - Mock setup is longer than the actual test.
                        - Testing implementation details instead of outcomes.

                        **Alternative**: consider using **fakes** (simple in-memory implementations) for repositories and external services.

                    </textarea>
                </section>

            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-flask-vial"></i> Testing CDI Applications</h2>
                </section>

                <section data-markdown style="font-size: 0.6em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-flask-vial"></i> Testing with @QuarkusTest

                        Quarkus provides integration testing with the CDI container:

                        ```java
                        @QuarkusTest
                        class GreetingResourceTest {

                            @Inject
                            GreetingService greetingService;  // Real CDI bean

                            @InjectMock
                            ExternalApiClient apiClient;  // Replaced with mock

                            @Test
                            void shouldGreetUser() {
                                // Configure mock behavior
                                when(apiClient.fetchUserName(1L)).thenReturn("Alice");

                                // Test with real CDI wiring + mocked dependency
                                String greeting = greetingService.greet(1L);

                                assertEquals("Hello, Alice!", greeting);
                                verify(apiClient).fetchUserName(1L);
                            }
                        }
                        ```

                        `@InjectMock` replaces the real bean with a Mockito mock **in the CDI container**.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-flask-vial"></i> Unit vs Integration Testing

                        | Aspect | Unit Test | @QuarkusTest |
                        |--------|-----------|--------------|
                        | **Speed** | Fast (ms) | Slower (seconds) |
                        | **CDI Container** | No | Yes |
                        | **Dependencies** | All mocked | Mix of real and mocked |
                        | **Scope** | Single class | Multiple beans |
                        | **Use case** | Logic testing | Integration testing |

                        **Recommendation:**
                        - Write **many unit tests** for business logic (fast feedback).
                        - Write **fewer integration tests** for critical paths (confidence).
                        - Use `@QuarkusTest` when real CDI behavior is needed (interceptors, events, etc.).

                    </textarea>
                </section>

            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fa-solid fa-hand-paper"></i> Exercise</h2>
                </section>
                <section data-markdown style="font-size: 0.5em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-hand-paper"></i> Use Jakarta CDI to represent a library

                        Implement a **Book** object with a **title**, an **author**, and, optionally, a **borrower**.

                        Implement a Publisher bean that **publishes** two books:
                        - "The Lord of the Rings" by J.R.R. Tolkien qualified as "Heroic Fantasy"
                        - "Dune" by Frank Herbert qualified as "Science Fiction"

                        Implement a Shelf bean that **holds** books for the library.
                        - The shelf should be filled with the "Heroic Fantasy" books when it is created.
                        - The shelf should offer a method to retrieve books by title.

                        Implement a **Librarian** bean that offers services to **borrow** and **return** books.
                        - A client should be able to borrow a book from the librarian.
                        - A client should be able to return a book to the librarian.
                        - The librarian has access to the shelf.

                        Whenever a book is removed from the shelf, it should be stamped and marked as borrowed.
                        Implement this behavior with a decorator on the shelf.

                        Whenever a book is borrowed or returned, a bell should ring in the library.
                        Implement this behavior with an interceptor on the librarian.

                        The library **Manager** is a control freak and asks to be notified whenever a book is returned.
                        Implement this behavior with an observer triggered by the librarian.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.5em;" data-separator-notes="^Notes:">
                    <textarea data-template>
                        ## <i class="fa-solid fa-hand-paper"></i> Solution

                        Check out the [solution](https://github.com/amt-classroom/example-cdi) on GitHub.

                    </textarea>
                </section>
            </section>

            <section>
                <h2><i class="fas fa-hand-paper"></i> Questions?</h2>
            </section>

        </div>
    </div>
</body>

</html>